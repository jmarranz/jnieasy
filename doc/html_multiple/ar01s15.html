<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Serialization</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title=""><link rel="up" href="index.html" title=""><link rel="prev" href="ar01s14.html" title="Multithreading support"><link rel="next" href="ar01s16.html" title="XML Descriptors reference"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Serialization</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s14.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s16.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id532027"></a>Serialization</h2></div></div></div><p>Native capable classes (user and predefined) are &#8220;serializable aware&#8221;.</p><p>Every native capable class has two internal non-static fields: jnieasyType and jnieasyNativeStateManager, both fields are declared as transient, and not serialized by default, this ensures the &#8220;native state&#8221; is not serialized. Any other field holds data and must be serialized.</p><p>All predefined native classes implement Serializable and Cloneable interfaces, user defined arrays and pointers implement these interfaces too by default, user defined Java structures, C++ classes and unions do not, the developer can do it explicitly. </p><p>The serialized map of a user defined class not enhanced and enhanced is the same but the serial UID is different, to avoid this, a serialVersionUID field must be added, for instance:</p><p>private static final long serialVersionUID = 1L; </p><p>this ensures that a serialized enhanced class instance can be deserialized as a not enhanced class instance and vice versa.</p><p>The serialization compatibility between enhanced and not enhanced classes is very important to pass objects in a distributed environment, a peer can use the enhanced version of the class and the other peer can use the non-enhanced version.</p><p>A native instance can be serialized and distributed, of course the deserialized instance is non-native, and can be again made native if the peer works with JNIEasy (using the attach and makeNative methods). There is a problem: serialization uses Java reflection, Java reflection is not controlled by the enhancer, if an instance is going to be serialized and the serialized instance must be a copy of the current native memory state, a deep &#8220;unfetch&#8221; must be performed before the serialization process. </p><p>Another option is to serialize non-native instances; of course a native instance can be freed or detached, but to keep the native object tree untouched there are two NativeManager methods to use a detached cloned object tree instead the &#8220;live&#8221; objects:</p><div class="orderedlist"><ol type="1"><li><p>Object detachCopy(Object obj)</p></li></ol></div><p>Creates a &#8220;deep&#8221; detached clone of the native object argument and tree (native fields). The native relations are cloned too (the detached tree is independent from the original) including circular relationships (direct and indirect).</p><div class="orderedlist"><ol type="1"><li><p>void attachCopy(Object nativeObj,Object detachedObj)</p></li></ol></div><p>Copy the content of a non-native object to a native object (both objects must have the same type). The non-native object is kept as is, but member native capable objects are made native and member of the native object.</p><p>Using these methods an entire native tree can be cloned, serialized, distributed, unserialized and copied to a symmetric native tree.</p><p>Example:</p><p>public class MyStructure </p><p>implements MakeNativeCallback,Serializable,Cloneable</p><p>{</p><p>...</p><p>}</p><p></p><p>MyStructure struct = new MyStructure(); </p><p>JNIEasy.get().getNativeManager().makeNative(struct);</p><p></p><p>MyStructure struct2 = new MyStructure(); </p><p>JNIEasy.get().getNativeManager().makeNative(struct2);</p><p></p><p>MyStructure structCopy =</p><p>(MyStructure)JNIEasy.get().getNativeManager().detachCopy(struct);</p><p></p><p>ByteArrayOutputStream repOut = new ByteArrayOutputStream();</p><p>ObjectOutputStream oos = new ObjectOutputStream(repOut);</p><p>oos.writeObject(struct);</p><p>oos.close(); </p><p></p><p>ByteArrayInputStream repIn = </p><p>new ByteArrayInputStream(repOut.toByteArray());</p><p>ObjectInputStream ois = new ObjectInputStream(repIn);</p><p>MyStructure structCopy2 = (MyStructure)ois.readObject();</p><p>ois.close();</p><p></p><p>System.out.println("Must be true: " + (struct2.getIntArray3() != null)); </p><p>structCopy2.setIntArray3(null); </p><p>JNIEasy.get().getNativeManager().attachCopy(struct2,structCopy2);</p><p>System.out.println("Must be null: " + struct2.getIntArray3());</p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s14.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s16.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Multithreading support </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> XML Descriptors reference</td></tr></table></div></body></html>
