<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Runtime Life Cycle</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title=""><link rel="up" href="index.html" title=""><link rel="prev" href="ar01s05.html" title="Declaration and creation of native capable objects"><link rel="next" href="ar01s07.html" title="Definition of user defined JAVA NATIVE METHODS AND classes"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Runtime Life Cycle</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s05.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s07.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id520115"></a>Runtime Life Cycle</h2></div></div></div><p>The runtime life cycle of a native capable object is very simple, there are only two states: native and non-native.</p><p>Every native capable class has, at least, two protected transient instance fields defined by the framework (added by the enhancer if the class is user defined). If the class inherits from another native capable class, both fields are present in the top most native capable class:</p><div class="orderedlist"><ol type="1"><li><p>TypeNative jnieasyType</p></li></ol></div><p>References the native type declaration to be used by the object when native. The referenced native type object is ever present although the object is not native. It can be obtained with the method NativeCapable.jnieasyGetType().</p><div class="orderedlist"><ol type="1"><li><p>NativeStateManager jnieasyNativeStateManager</p></li></ol></div><p>References the native state manager object. This per-instance object manages the native state of the native instance. It can be obtained with the method NativeCapable.jnieasyGetNativeStateManager() or with NativeCapableUtil.getNativeStateManager(Object)</p><p>A native capable object is native when a NativeStateManager object is associated, the jnieasyGetNativeStateManager() method or returns this object , if not native returns null.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id520184"></a>Framework initialization</h3></div></div></div><p>First of all the framework must be loaded/initialized:</p><p>JNIEasy jniEasy = JNIEasy.get();</p><p>jniEasy.load();</p><p>This sentence loads the JNIEasy&#8217;s dynamic library/shared object (JNIEasy.dll on Windows, libJNIEasy.so on Linux and Solaris, libJNIEasy.jnilib on Mac OS X). </p><p>On loading, the framework needs to locate the product&#8217;s license file, JNIEasy.lic, this file is looked for in the directory specified with the optional JNIEASY_LICENSE_DIR Java property (specified with a &#8211;D flag on command line), otherwise the current directory is looked for.</p><p>Optionally the license directory can be specified programmatically using the method JNIEasy.setFeature(String,Object) and the feature &#8220;jnieasy.license.dir&#8221; before calling the load() method:</p><p>JNIEasy jniEasy = JNIEasy.get();</p><p>jniEasy.setFeature("jnieasy.license.dir","some path");</p><p>jniEasy.load();</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id520247"></a>Making native a native capable object</h3></div></div></div><p>There are several ways to make native a native capable object:</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id520256"></a>Allocating native memory</h4></div></div></div><p>The method NativeManager.makeNative(Object) makes native the native capable object specified. This call allocates the necessary native memory, creates a new NativeStateManager object to manage this memory, associates to the object, and &#8220;unfetches&#8221; the values of contained native fields to the native memory recursively (a &#8220;deep&#8221; unfetch). After this call the object and referenced by fields (reachable) native capable objects are made native and the allocated memory is in sync with the field values before the call.</p><p>The primitive fields are simply copied to the matched native memory.</p><p>An object referenced by a native field with a native capable class type, is made native:</p><div class="orderedlist"><ol type="1"><li><p>Allocating native memory if the field is declared &#8220;by pointer&#8221;: the address of the new memory block is set to a pointer of the container&#8217;s memory according to the native memory layout.</p></li><li><p>Or attaching to the start of a memory part of the container&#8217;s native memory if the field is declared &#8220;by value&#8221;, according to the native memory layout.</p></li><li><p>If the native field type is a &#8220;can be native class&#8221; (e.g. String, int[]) an internal auxiliary native object is used holding the object referenced by the field. This auxiliary object is made native as explained before.</p></li><li><p>The native instance owns its related native memory; the pair native instance-address is registered internally by the framework. </p></li></ol></div><p>Only one object can be the owner of a native address.</p><p>A shortcut to obtain the native address is invoking the static method NativeCapableUtil.getAddress(Object); the same instance is returned by the method NativeManager.findObject(long)using the previously returned address (it only works if the object owns the memory associated). </p><p>If the framework needs a native object to represent a native address, first looks in the internal registry to locate the native object owning this address, if not found creates a new native capable object (with the expected type) and attaches it to the address.</p><p>Example:</p><p>Consider this class declared as a C structure in the XML enhancer descriptor of the class (only fields are declared as native, no methods):</p><p>package examples.manual;</p><p>import com.innowhere.jnieasy.core.*;</p><p>import com.innowhere.jnieasy.core.data.*;</p><p>import com.innowhere.jnieasy.core.factory.*;</p><p>import com.innowhere.jnieasy.core.mem.*;</p><p></p><p>public class MyStructure</p><p>{</p><p>protected int anInt = -1;</p><p>protected NativeIntegerArray intArr1; </p><p>// Declared "by pointer" length undefined</p><p>protected NativeIntegerArray intArr2; </p><p>// Declared "by value" length 2</p><p>protected int[] intArr3 = new int[]{5,6}; </p><p>// Declared "by pointer" length 2 </p><p>protected int[] intArr4 = new int[]{7,8}; </p><p>// Declared "by value" length 2 </p><p></p><p>public MyStructure()</p><p>{</p><p>NativeCapableFactory factory = </p><p>JNIEasy.get().getNativeCapableFactory();</p><p>intArr1 = (NativeIntegerArray)factory.wrapValue(new int[]{1,2});</p><p>intArr2 = (NativeIntegerArray)factory.wrapValue(new int[]{3,4});</p><p>} </p><p>}</p><p>An example of use:</p><p>MyStructure obj = new MyStructure();</p><p>NativeManager natMgr = JNIEasy.get().getNativeManager();</p><p>natMgr.makeNative(obj);</p><p>long address = NativeCapableUtil.getAddress(obj);</p><p>Object obj2 = natMgr.findObject(address);</p><p>System.out.println("Must be true: " + (obj == obj2));</p><p>Supposed a 32 bit platform, the native memory layout after made native is:</p><p>
<img src="" width="NaN">
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id520538"></a>Attaching native memory</h4></div></div></div><p>A native capable object may be attached to a previously known (supposed valid) native address and memory zone starting in this address, corresponding to the expected memory layout of the instance. When attaching, a new NativeStateManager object is created, attached to the native address and associated to the object (now native).</p><p>The attached native instance does not own its related native memory. Several native objects may be attached to the same native address and they are not registered as &#8220;owners&#8221; of the address. A native instance may be attached to an address owned by another native instance (created with NativeManager.makeNative(Object)); the framework tries to avoid this because it looks first for a native instance owning the address, but the user can attach explicitly.</p><p>There are two ways to attach a native capable object to a native address:</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id520570"></a>Native memory is overwritten (unfetch-attach)</h5></div></div></div><p>The method NativeManager.makeNative(Object,long) is used. The current values of the native fields are mandatory over the native memory, and native memory is overwritten (&#8220;unfetched&#8221;) following the rules explained before in the Allocating native memory section using the method NativeManager.makeNative(Object). The differences are: no new native memory is allocated and the attached native object does not own the associated native memory/address.</p><p>Example:</p><p>MyStructure original = new MyStructure();</p><p>NativeManager natMgr = JNIEasy.get().getNativeManager();</p><p>natMgr.makeNative(original);</p><p>original.setIntArray3(null);</p><p>System.out.println("Must be null: " + original.getIntArray3());</p><p>long address = NativeCapableUtil.getAddress(original);</p><p></p><p>MyStructure attached = new MyStructure();</p><p>natMgr.makeNative(attached,address); </p><p>attached.setIntArray3(new int[]{1,2}); </p><p>/* Modifies the native memory of &#8220;original&#8221; */ </p><p>System.out.println("Must be 1: " + original.getIntArray3()[0]);</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id520651"></a>Native memory is kept untouched (attach)</h5></div></div></div>Native memory is kept untouched (attach)<p>The method NativeManager.attach(Object,long) is used. The native memory state is mandatory over the fields, but there is no fetch of the native memory to fields, because when a Java field is read, the field is synchronized before with the native value (the Java value is set with the native value, native memory is fetched). Using this lazy synchronization increases the performance if a small part or no fields are used and ensures the field value read is ever the current native memory value: native memory can be modified from native in any time, a very important feature in a multithread programming world. Of course any Java field updated writes the new value to the native memory (there is no difference between an object attached or owning the native memory when fields are read and written). To ensure the Java fields are fully synchronized with the native memory, the method NativeManager.fetch(Object,long) can be called after the attach call.</p><p>Example:</p><p>MyStructure original = new MyStructure();</p><p>NativeManager natMgr = JNIEasy.get().getNativeManager();</p><p>natMgr.makeNative(original);</p><p>original.setIntArray3(new int[]{1,2});</p><p>System.out.println("Must be 2: " + original.getIntArray3()[1]);</p><p>long address = NativeCapableUtil.getAddress(original);</p><p></p><p>MyStructure attached = new MyStructure();</p><p>natMgr.attach(attached,address); </p><p>System.out.println("Must be 2: " + attached.getIntArray3()[1]); </p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id520724"></a>By reachability of the fields</h4></div></div></div><p>In the previous cases the referenced native capable objects of native fields are made native by reachability when the container object is made native or when is first accessed if attached (without unfetch).</p><p>Following the previous example:</p><p>public class MyStructure</p><p>{</p><p>... </p><p>public NativeIntegerArray getIntArray1()</p><p>{</p><p>return intArr1;</p><p>}</p><p></p><p>public void setIntArray1(NativeIntegerArray intArr1) </p><p>{</p><p>this.intArr1 = intArr1;</p><p>}</p><p>}</p><p></p><p>MyStructure obj = new MyStructure();</p><p>NativeManager natMgr = JNIEasy.get().getNativeManager();</p><p>natMgr.makeNative(obj);</p><p>NativeCapableFactory factory = JNIEasy.get().getNativeCapableFactory();</p><p>NativeIntegerArray newValue =</p><p>(NativeIntegerArray)factory.wrapValue(new int[]{10,11});</p><p>obj.setIntArray1(newValue);</p><p></p><p>The new value, newValue, is not native before updating the intArr1 field; the new referenced object will be made native automatically before the field is set, because the field is native and the method code is managed by the enhancer.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id520829"></a>Reading and updating native instances</h3></div></div></div><p>The native fields of user defined native capable classes must not be accessed directly outside the class, because any access must be done on managed (enhanced) code to be policed by the enhancer, currently only the instance member methods and constructors of the native capable class are enhanced (managed code), any access of the native fields is monitored and synchronized, if necessary, with the native memory.</p><p>The fields of predefined classes are ever accessed using the implemented methods of the related native interface; these methods synchronize the fields with the native memory as the enhancer does with user defined classes.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id520844"></a>Reading fields of user defined native capable classes</h4></div></div></div><p>The native memory is ever mandatory over the current values of the fields. When a native field is read, the native memory is ever read first, and the field value is modified with the current matched value of the native memory, although the field has not been modified after the last read on the Java side. Any reading action must be seen as &#8220;I want to read the native memory&#8221;, because the &#8220;Java state&#8221; may remain the same between readings, but the native memory may have changed in the native side, or with direct access to the native memory using the NativeBuffer, into the same or another thread (the threads synchronization is a developer&#8217;s work).</p><p>Although the field is read from the user point of view, the field value is updated if native memory is different to the current field value.</p><p>The following descriptions apply to fields of user defined native capable classes. The default fetch mode is supposed to be &#8220;fast&#8221;.</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id520888"></a>Reading a field with a primitive type</h5></div></div></div><p>The native memory is read and copied to the field and returned.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id520898"></a>Reading a field with a native capable class type declared &#8220;by pointer&#8221;</h5></div></div></div><p>The matched native memory of the field is a pointer. </p><div class="orderedlist"><ol type="1"><li><p>If the address value is 0 (null): the field is set to null and the current native object referenced, if any, is lost (this object remains unchanged, if not referenced any more is garbage collected).</p></li><li><p>If the address value is not null : the address is compared with the address of the current referenced native object (if any), if equal the current referenced object is returned, if not equal, the framework search in the internal registry the native instance owning the address, if found this object is returned (the object pointed) and the current object is discarded, if not found and the current object is native then is discarded (pointer has changed) and a new attached object to the address is returned, else (if not native) the current object is attached to the address and returned.</p></li></ol></div></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id520959"></a>Reading a field with a native capable class type declared &#8220;by value&#8221;</h5></div></div></div><p>The matched native memory is a part of the container object&#8217;s memory, the address is the start of this memory part (is managed by the framework as the pair container&#8217;s address - relative offset of the field). The field needs to reference a native object attached to this address (managing this memory part), if the field is null a new object is automatically created with the expected type, attached and returned. If the current referenced object already exists and is already native (then attached to the matched memory part), it is returned as is, and no synchronization of the instance and the native memory is performed (if the default fetch mode is set to &#8220;fast&#8221;), because any access to the fields of the returned object will perform this synchronization.</p><p>In brief: the native object attached to the matched native memory part is returned, and is previously created and attached if necessary.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id521003"></a>Reading a field with a &#8220;can be native&#8221; class type declared &#8220;by pointer&#8221;</h5></div></div></div><p>An auxiliary native object linked to the field, implementing the CanBeNativeCapable interface, is used; this auxiliary object is managed by the container&#8217;s NativeStateManager object. This auxiliary object is managed following the same rules of a field with a native capable class &#8220;by pointer&#8221;, as if the field type was a native capable class referencing this auxiliary object. This object is not finally returned because is expected a &#8220;can be native&#8221; object (a String, int[] etc.), the auxiliary object, if not null, is used to obtain the &#8220;can be native&#8221; object with the same value of the native memory &#8220;pointed&#8221; calling the method NativeSingleFieldContainer.getValue(int) using the default fetch mode (&#8220;fast&#8221; by default). </p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id521029"></a>Reading a field with a &#8220;can be native&#8221; class type declared &#8220;by value&#8221;</h5></div></div></div><p>In this scenario the field must be not null, because the referenced object represents the always present related memory part of the container&#8217;s native memory (when native of course), otherwise an exception is thrown.</p><p>When reading, an auxiliary object is needed too, as the &#8220;by pointer&#8221; case, but this object is attached to the matched native memory part represented by the field, following the same rules of a field with a native capable class &#8220;by value&#8221;, and never is discarded. Because the current &#8220;can be native&#8221; object is never null, the auxiliary object used to obtain the expected &#8220;can be native&#8221; object is never null too (is created if necessary), and again the &#8220;can be native&#8221; object to return is obtained with the method NativeSingleFieldContainer.getValue(int) using the default fetch mode (&#8220;fast&#8221; by default), the returned &#8220;can be native object&#8221; is previously synchronized with the matched native memory part; if the &#8220;can be native&#8221; object is modifiable (int[] etc) the current but modified object is returned, else a new object is created, synchronized and returned.</p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id521094"></a>Updating fields of user defined native capable classes</h4></div></div></div><p>Again the framework supposes the native memory may be update in the native side, or using direct access to the native memory using the NativeBuffer. When a native field is updated, the native memory is ever updated too although the new value is the same as the current value of the field, this ensures that the native memory is really updated. Any updating action must be seen as &#8220;I want to update the native memory&#8221;, because the &#8220;Java state&#8221; may remain the same but the native memory may have changed indirectly. A valid technique is to update a field with the same value to ensure the native memory is set with this value.</p><p>The following descriptions apply to fields of user defined native capable classes. The default &#8220;unfetch&#8221; mode is supposed to be &#8220;fast&#8221;.</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id521132"></a>Updating a field with a primitive type</h5></div></div></div><p>The field and related native memory are updated with the new value.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id521141"></a>Updating a field with a native capable class type declared &#8220;by pointer&#8221;</h5></div></div></div><p>The matched native memory is a pointer. If the new object value is null the pointer is set to 0, else the new object is made native, if necessary, and its address is set as the value of the pointer in the native memory. Any previously referenced object by the field is unreferenced.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id521156"></a>Updating a field with a native capable class type declared &#8220;by value&#8221;</h5></div></div></div><p>The matched native memory is a part of the container&#8217;s memory. The new object can not be null (otherwise an exception is thrown), if the object is not native is made native with an unfecth-attach otherwise the native memory is not modified (if the default &#8220;unfetch&#8221; mode is &#8220;fast&#8221;). </p><p>Updating a &#8220;by value&#8221; field must be used to update the container object managing the matched native memory part, but not the native memory itself, because the field value (the manager of the memory part) may be used itself to update the native memory, using its methods or passing as a parameter to NativeManager.unFetch(Object).</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id521190"></a>Updating a field with a &#8220;can be native&#8221; class type declared &#8220;by pointer&#8221;</h5></div></div></div><p>If the new value is null the matched native pointer is set to 0 and the current auxiliary object is discarded, else if the auxiliary native object is missing, a new object is created and made native wrapping the new &#8220;can be native&#8221; value (the native memory of the new object is updated with the &#8220;can be native&#8221; value), else if the new value is not equal to the current field value, the current auxiliary object is discarded and a new auxiliary object is created and made native wrapping the new value. Unless the new value is null, the native address of the final auxiliary object is used to update the native pointer, else is set to 0. The native memory is ever updated although the new value is the same as current value because the native pointer may be changed or in the native side, or using direct access to the native memory.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id521221"></a>Updating a field with a &#8220;can be native&#8221; class type declared &#8220;by value&#8221;</h5></div></div></div><p>The auxiliary object is used, it is created and unfetch-attached if was not; this object is used as the manager of the matched native memory part and never is discarded as said in &#8220;reading&#8221;. The new &#8220;can be native&#8221; value is used to update the native memory part using the auxiliary object with the default &#8220;unfetch&#8221; mode.</p><p>Note that the native memory is ever updated although the new value is identical to the current value because the native memory may have been updated indirectly.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id521249"></a>Updating elements of Java array fields</h5></div></div></div><p>The enhancer does not control the updating of an element of a Java array field.</p><p>Considering the following code:</p><p>public class MyStructure </p><p>{</p><p>...</p><p>protected int[] intArr3 = new int[]{5,6}; </p><p>// Declared "by pointer" length 2</p><p>...</p><p>public int[] getIntArray3() </p><p>{ </p><p>return this.intArr3;</p><p>}</p><p></p><p>public void setIntArray3(int[] intArr3) </p><p>{ </p><p>this.intArr3 = intArr3;</p><p>}</p><p>public void setIntArray3(int index,int value) </p><p>{</p><p>this.intArr3[index] = value;</p><p>}</p><p>}</p><p>The fields access &#8220;this.intArr3[index]&#8221; implies a native memory read updating the current Java array value with the native memory. But the element modification is not detected by the enhancer and no native memory update is performed.</p><p>Several solutions to this problem:</p><div class="orderedlist"><ol type="1"><li><p>Updating the method as: </p></li></ol></div><p>public void setIntArray3(int index,int value) </p><p>{</p><p>int[] aux = this.intArr3;</p><p>aux[index] = value;</p><p>this.intArr3 = aux;</p><p>}</p><p>The last sentence ensures the native memory is updated with the whole array. </p><div class="orderedlist"><ol type="1"><li><p>Re-setting the modified array:</p></li></ol></div><p>MyStructure obj = ... // a native instance</p><p>int[] arr = obj.getIntArray3();</p><p>arr[index] = ... // element modifications</p><p>obj.setIntArray3(arr); // updates the whole array</p><div class="orderedlist"><ol type="1"><li><p>Using a corresponding native class array wrapper as field and use &#8220;by element access&#8221; methods:</p></li></ol></div><p>protected NativeIntegerArray intArr3;</p><p>The NativeIntegerArray interface has the method void setInt(int index,int value) updating only the selected element in native memory. The method int getInt(int index) is more performant too because only the selected element is read from native memory. </p><p>This alternative increments the performance and control but decreases the transparency, is only recommended with big arrays used with frequent access to the elements.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id521467"></a>Updating elements of StringBuffer fields</h5></div></div></div>Updating elements of StringBuffer fields<p>The enhancer does not control the updating of a StringBuffer using its methods, use similar techniques seen with Java arrays.</p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id521478"></a>Reading/writing the native memory of CanBeNativeCapable objects</h4></div></div></div>Reading/writing the native memory of CanBeNativeCapable objects<p>The CanBeNativeCapable objects enable the developer to read from and write to native memory &#8220;can be native&#8221; objects. These utility objects are used as auxiliary objects to manage &#8220;can be native&#8221; fields behind the scenes; these objects can be used explicitly too. </p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id521497"></a>Reading/Writing NativeString based objects</h5></div></div></div>Reading/Writing NativeString based objects<p>When a NativeString object is made native allocating memory, the current String value is copied (using the specified encoding) in the native memory, the memory size is the string length + 1 (the '\0' character) multiplied with the character size, this memory size can not change. If the object is attached and no String was set before, in this case the memory size is undefined, this case is specially useful on reading strings with unknown length (the NativeString object is attached to native memory and the length is unknown), usually using the method NativeString.getString().</p><p>When reading, the current String object is returned if the native memory contains the same string as the current String object, else a new String is returned. </p><p>When writing, usually using the method NativeString.setString(String), the new value is written in the native memory, but the string length can not be greater than the length of the original String value immediately before the container is made native allocating memory, unless the object was attached and no String was set before (memory size is undefined), in this case the framework can not check an out of bounds writing.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id521534"></a>Reading/Writing NativeStringBuffer based objects</h5></div></div></div>Reading/Writing NativeStringBuffer based objects<p>The behavior is mainly the same as NativeString objects, with only one difference: when reading, the returned StringBuffer is ever the current object because this object is modifiable.</p><p>With the methods getCharacter(int index)and setCharacter(int index,int value), individual characters can be read/modified, this supposes a performance gain instead of reading/updating the complete string. Furthermore using these methods can be read/updated individual characters of very big native strings without duplication in Java: if a NativeStringBuffer object is attached to a known address and no StringBuffer was set before, the memory size is unknown and no internal StringBuffer object was created (no duplication of the string), the methods getCharacter(&#8230;) and setCharacter(&#8230;) can be used to access individual characters without having read/update the whole native string; if the method getStringBuffer() is used the whole native string is read (supposed that a final '\0' exists) and duplicated inside an internal StringBuffer object.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id521575"></a>Reading/writing arrays with undefined length</h5></div></div></div><p>In a similar fashion as NativeStringBuffer objects, any native object implementing the NativeArray interface can deal with undefined length arrays: if an object is attached to a known address and no Java array was set before, the memory size is unknown and no internal Java array is hold, and can not because array length is unknown, the methods like NativeObjectArray.getObject(int index), NativeObjectArray.setObject(int index,Object value), NativeIntegerArray.getInt(int index), NativeIntegerArray.setInt(int index) and so on, can be used to read/update individual elements without read/update the entire array.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id521594"></a>Reading/writing primitive arrays</h5></div></div></div><p>These objects implement the interface NativePrimitiveArray. Primitive arrays are optimized to read and write big arrays, because the copy operation between native memory and Java array (both directions) is realized using the complete memory block of the array. Remainder array classes read and write element by element.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id521607"></a>Reading/writing arrays of &#8220;can be native&#8221; objects</h5></div></div></div><p>These objects implement the interface CanBeNativeCapableArray, a native instance uses internally an auxiliary array (with the same length) of auxiliary native objects. The relation of the pair array element-auxiliary native objects follow the same relationship explained on &#8220;can be native&#8221; fields of user defined classes; the processing is different if the array holds elements &#8220;by value&#8221; of &#8220;by pointer&#8221;.</p><p>With undefined length arrays the auxiliary array dynamically increase until necessary to manage the selected element read/updated.</p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id521641"></a>Fetch and &#8220;unfetch&#8221; modes</h4></div></div></div>Fetch and &#8220;unfetch&#8221; modes<p>&#8220;Fetch&#8221; is the operation to read from native memory and copy to Java memory. &#8220;Unfetch&#8221; is the operation to write the native memory with the data copied from Java memory.</p><p>All reading and writing operations between Java and native memory have any kind of &#8220;deepness&#8221;. There are four types of deepness:</p><div class="orderedlist"><ol type="1"><li><p>NONE: there is no copy between Java memory and native memory, the reading and writing operations are performed on Java memory only. The NONE mode may be used to read or update Java fields with no native memory interaction.</p></li><li><p>FAST: only field members with primitive types, &#8220;can be native&#8221; class types and the address of fields with native capable class types &#8220;by pointer&#8221;, are synchronized with the native memory; fields with native capable class types &#8220;by value&#8221; are not synchronized because the native &#8220;embedded&#8221; object can be used, itself, to access the associated native memory. The referenced native object of a field with a native capable class type declared &#8220;by pointer&#8221;, is not synchronized itself, only the object&#8217;s address and the related pointer in the container&#8217;s native memory are synchronized.</p></li><li><p>EMBEDDED: the native objects referenced by fields with native capable class types declared &#8220;by value&#8221; (native embedded objects) are synchronized, themselves, with the related native memory too.</p></li><li><p>DEEP: the native objects referenced by fields with native capable class types declared &#8220;by pointer&#8221; (native linked objects) are synchronized, themselves, with the related native memory too. All members of the native object are synchronized recursively. Cyclic references are detected with no problem.</p></li></ol></div><p>The following table shows if a field is synchronized (fetched/unfetched) with the native memory if accessed (read/write) depending on the fetch/unfetch mode and field type:</p><div class="informaltable"><table border="1"><colgroup><col><col><col><col><col></colgroup><tbody><tr><td>
<p>Native Field Type</p>
</td><td>
<p>NONE</p>
</td><td>
<p>FAST</p>
</td><td>
<p>EMBEDDED</p>
</td><td>
<p>DEEP</p>
</td></tr><tr><td>
<p>Primitive</p>
</td><td>
<p>NO</p>
</td><td>
<p>YES</p>
</td><td>
<p>YES</p>
</td><td>
<p>YES</p>
</td></tr><tr><td>
<p>&#8220;Can be native&#8221; (by value &amp; by pointer)</p>
</td><td>
<p>NO</p>
</td><td>
<p>YES</p>
</td><td>
<p>YES</p>
</td><td>
<p>YES</p>
</td></tr><tr><td>
<p>Native capable by pointer</p>
</td><td>
<p>NO</p>
</td><td>
<p>YES, address only</p>
</td><td>
<p>YES, address only</p>
</td><td>
<p>YES, referenced object&#8217;s fields with DEEP mode too</p>
</td></tr><tr><td>
<p>Native capable by value (referenced object already attached)</p>
</td><td>
<p>NO</p>
</td><td>
<p>NO</p>
</td><td>
<p>YES, the referenced object&#8217;s fields with EMBEDDED mode too</p>
</td><td>
<p>YES, the referenced object&#8217;s fields with DEEP mode too</p>
</td></tr></tbody></table></div><p></p><p>The default mode to fetch and &#8220;unfetch&#8221; is FAST, the fast mode ensures a reasonable synchronization of Java memory and native memory. </p><p>The Fetch y UnFetch interfaces define the constants used to specify the fetch and &#8220;unfetch&#8221; modes. </p><p>The developer can:</p><div class="orderedlist"><ol type="1"><li><p>change the default fetch and &#8220;unfetch&#8221; mode of every read and write operation with the methods NativeManager.setDefaultFetchMode(int) and NativeManager.setDefaultUnFetchMode(int)</p></li><li><p>use the fetchMode or unFetchMode parameters present in multiple read/write methods of NativeCapable inherited interfaces</p></li><li><p>execute a fetch or &#8220;unfetch&#8221; operation over a native instance with the methods NativeManager.fetch(Object obj,int mode) and NativeManager.unFetch(Object obj,int mode).</p></li></ol></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id522020"></a>Freeing a native instance</h3></div></div></div><p>If the native instance owns its native memory (was made native with NativeManager.makeNative(Object)); this native memory is automatically freed if the native instance goes out the scope and is reclaimed by the garbage collector. This is realized by the finalize() method of the internal implementation of NativeStateManager, the finalize method of the native instance is not used and the developer can use it with freedom in user defined classes. </p><p>There are two methods to free the native memory of a native object explicitly:</p><p>NativeManager.free(Object)</p><p>NativeCapableUtil.free(Object)</p><p>Both methods are roughly equivalent: if the object owns its native memory, the native memory is freed else does nothing, in both cases the native instance is made not native. The embedded native object fields are freed too (native objects pointed by fields &#8220;by pointer&#8221; are untouched).</p><p>There are two methods to detach a native object from the native memory without freeing it:</p><p>NativeManager.detach(Object)</p><p>NativeCapableUtil.detach(Object)</p><p>Both methods are roughly equivalent too: the object is detached from the related native memory and made not native. The embedded native object fields are detached too (native objects pointed by fields &#8220;by pointer&#8221; are untouched). The developer must free the detached native memory if necessary (taking care with memory leaks). </p><p>To free (and make not native) an entire object tree (freeing linked objects too) the following method can be used: </p><p>NativeManager.detach(Object obj,int freeMemMode,boolean deep) </p><p>with the parameters freeMemMode set to FREE_MEMORY and deep to true.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s05.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s07.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Declaration and creation of native capable objects </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Definition of user defined JAVA NATIVE METHODS AND classes</td></tr></table></div></body></html>
