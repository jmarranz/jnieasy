<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Java Code Generation</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title=""><link rel="up" href="index.html" title=""><link rel="prev" href="ar01s08.html" title="Enhancer"><link rel="next" href="ar01s10.html" title="Direct memory manipulation"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Java Code Generation</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s08.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s10.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id528965"></a>Java Code Generation</h2></div></div></div><p>The Java code generation utilities are especially useful to generate the Java proxy code of methods (usually C methods) of DLLs exporting tons of methods. Usually a program uses a small group of methods of a big DLL, for example the Windows User.dll, the enhancer approach can spend very much time and memory initializing all proxy methods, used or not used in the program. The Java code generated by the generation utilities follows the principle: &#8220;the first use creates the proxy&#8221;, there is no creation and registry of any internal proxy instance (using DynamicLibrary methods) until the method is first used, the second time will use the previously created proxy. The typical approach is group the C exported methods of a DLL in the same code generated Java class.</p><p>The generated methods are not synchronized to achieve the maximum performance, but they can work in a multithread environment because the creation of proxy instances is synchronized by the framework (the framework ensures the creation of a single proxy instance when two threads try in the same instant to create the same proxy instance).</p><p>In spite of the main objective is to generate C proxy methods, constructors and C++ proxy methods can be generated too, the generated Java class can be enhanced in a following step. This is another approach to create native capable classes with methods working as proxy of C/C++ methods, these proxy methods with generated code do not need to be enhanced (they work already as proxies), use this technique if you are more comfortable with less code hidden by the enhancer.</p><p>The generation task is usually performed using the NativeJavaCodeGeneratorCmd class in the command line or Ant task, or using the method: </p><p>NativeJavaCodeGenerator.generate(String,String,String[],String[])</p><p>In both cases, the generation is made in &#8220;batch&#8221; mode using a &#8220;root&#8221; XML file listing the XML code generation descriptor files of classes to be generated. The name of this &#8220;root&#8221; XML file is not fixed, the XML generation descriptor of a class neither has a fixed name, but the following format is recommended:</p><p>SimpleClassName.jnieasy.jgen.xml</p><p>The XML file syntax is very similar to the enhancer counterpart.</p><p>The following example file (proxygen.xml) is an example of a XML root file:</p><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p><p>&lt;!-- proxygen.xml --&gt;</p><p>&lt;jniEasyJavaCodeGen version="1.1"&gt;</p><p>&lt;include file="MyCPPClassOnDLLGen.jnieasy.jgen.xml" /&gt;</p><p></p><p>&lt;include file="inc/proxygen2.xml" /&gt; </p><p>&lt;/jniEasyJavaCodeGen&gt;</p><p>An example of a XML generation class descriptor file: it follows a similar syntax to the enhancer counterpart (using MSVC name mangling, the same example in the distribution is cross-compiler):</p><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p><p>&lt;!-- MyCPPClassOnDLLGen.jnieasy.jgen.xml --&gt;</p><p>&lt;jniEasyJavaCodeGen version="1.1"&gt;</p><p>&lt;fileGen name="MyCPPClassOnDLLGen"&gt; &lt;!-- generator adds .java --&gt;</p><p>&lt;package name="examples.manual" &gt;</p><p>&lt;imports&gt;</p><p>&lt;import class="java.io.*" /&gt; </p><p>&lt;/imports&gt; </p><p>&lt;class name="MyCPPClassOnDLLGen" extends="Object" </p><p>implements="Serializable,Cloneable" </p><p>libraryPath="MyLibrary" &gt; </p><p></p><p>&lt;field class="int" name="virtualTable" /&gt;</p><p>&lt;field class="double" name="value" /&gt; </p><p></p><p>&lt;freeCode&gt;</p><p>protected int virtualTable;</p><p>protected double value;</p><p></p><p>/* Empty constructor */</p><p>MyCPPClassOnDLLGen()</p><p>{</p><p>} </p><p>&lt;/freeCode&gt; </p><p></p><p>&lt;constructor </p><p>nativeName="?create@MyCPPClassOnDLL@@SGPAV1@HH@Z"&gt;</p><p>&lt;param class="int" name="a" /&gt;</p><p>&lt;param class="int" name="b" /&gt; </p><p>&lt;/constructor&gt; </p><p></p><p>&lt;method name="destroy" methodType="C"</p><p>nativeName="?destroy@MyCPPClassOnDLL@@SGXPAV1@@Z"&gt;</p><p>&lt;return class="void" /&gt; </p><p>&lt;params&gt; </p><p>&lt;param class="MyCPPClassOnDLL" name="obj" /&gt;</p><p>&lt;/params&gt; </p><p>&lt;/method&gt; </p><p></p><p>&lt;method name="addStatic" methodType="C"</p><p>nativeName="?addStatic@MyCPPClassOnDLL@@SG_JHH@Z"&gt;</p><p>&lt;return class="long" /&gt; </p><p>&lt;params&gt; </p><p>&lt;param class="int" name="a" /&gt;</p><p>&lt;param class="int" name="b" /&gt;</p><p>&lt;/params&gt; </p><p>&lt;/method&gt;</p><p></p><p>&lt;method name="sub" methodType="CPP"</p><p>nativeName="?sub@MyCPPClassOnDLL@@UAGNHH@Z"&gt; </p><p>&lt;return class="double" /&gt; </p><p>&lt;params&gt; </p><p>&lt;param class="int" name="a" /&gt;</p><p>&lt;param class="int" name="b" /&gt; </p><p>&lt;/params&gt; </p><p>&lt;/method&gt; </p><p>&lt;method name="varargsEx" methodType="C"</p><p>nativeName="?varargsEx@MyCPPClassOnDLL@@SAXPADZZ" </p><p>callConv="c_call"&gt; </p><p>&lt;return class="void" /&gt; </p><p>&lt;params&gt; </p><p>&lt;param class="byte[]" name="buffer" /&gt;</p><p>&lt;param dec="Object..." name="args" /&gt; </p><p>&lt;/params&gt; </p><p>&lt;/method&gt;</p><p>&lt;/class&gt;</p><p>&lt;/package&gt;</p><p>&lt;/fileGen&gt;</p><p></p><p>&lt;/jniEasyJavaCodeGen&gt;</p><p></p><p>Generates a class file, MyCPPClassOnDLLGen.java, very similar to the class MyCPPClassOnDLL seen before, with the exception of the methods now containing the necessary proxy code to call the C/C++ matched method. </p><p>Note the name and class attributes of fields and methods (returns) missing in the enhancer version (because the code generation constructs the Java class from scratch). The extends and implements attributes are declared to illustrate its use. The import (tag) declaration is needed to resolve the Serialize interface in the generated class.</p><p>If the Java class references other user defined native capable class, this must be previously enhanced or must be located the XML enhancer descriptor in the classpath (because the on load enhancer is used if necessary)</p><p>The syntax of the NativeJavaCodeGeneratorCmd command is:</p><p>java com.innowhere.jnieasy.core.NativeJavaCodeGeneratorCmd </p><p>[-enhanceOnLoad includeImportList </p><p>[-excludeImports excludeImportList]] xmlDescriptorPath outputDir</p><p>The complete syntax is documented in the class NativeJavaCodeGeneratorCmd.</p><p>The distribution&#8217;s build.xml contains Ant task examples to call the code generation tool.</p><p>The top most root is proxygen.xml defined as:</p><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p><p>&lt;!-- proxygen.xml --&gt;</p><p>&lt;jniEasyJavaCodeGen version="1.1"&gt; </p><p>&lt;include file="manual/proxygen.xml" /&gt; </p><p>&lt;include file="win32exam/proxygen.xml" /&gt; </p><p>&lt;/jniEasyJavaCodeGen&gt;</p><p>The generated class MyCPPClassOnDLL must be enhanced later to work as a proxy of the MyCPPClassOnDLL C++ class, anyway, static methods can be called without enhancement (the main objective of the code generator, because most of the &#8220;big&#8221; DLLs are C libraries). </p><p>A partial result of the generated code:</p><p>package examples.manual;</p><p></p><p>import java.io.*; </p><p></p><p>public class MyCPPClassOnDLLGen extends Object </p><p>implements Serializable,Cloneable </p><p>{ </p><p>public static com.innowhere.jnieasy.core.JNIEasy jnieasyRoot = </p><p>com.innowhere.jnieasy.core.JNIEasy.get(); </p><p>public static com.innowhere.jnieasy.core.mem.DynamicLibrary </p><p>jnieasyDLL = </p><p>jnieasyRoot.getDLLManager().get("MyLibrary"); </p><p>public static com.innowhere.jnieasy.core.method.NativeBehavior[] </p><p>jniEasyMethodList = </p><p>new com.innowhere.jnieasy.core.method.NativeBehavior[ 4 ];</p><p>...</p><p>public static long addStatic(int a,int b) </p><p>{ </p><p>com.innowhere.jnieasy.core.method.NativeBehavior jnieasyMethod </p><p>= jnieasyMethodList[2]; </p><p>if (jnieasyMethod == null) </p><p>{ </p><p>String jnieasyFuncName = </p><p>"?addStatic@MyCPPClassOnDLL@@SG_JHH@Z";</p><p>jnieasyMethod = jnieasyMethodList[2] = </p><p>jnieasyDLL.addCMethod(jnieasyFuncName, </p><p> jnieasyRoot.getTypeManager().dec(long.class).decVarType(), </p><p>new java.lang.Object[]  {jnieasyRoot.getTypeManager().dec(int.class).decVarType().decParameter(), jnieasyRoot.getTypeManager().dec(int.class).decVarType().decParameter()}, </p><p>com.innowhere.jnieasy.core.typedec.CallConv.STD_CALL </p><p>); </p><p>} </p><p>return ((com.innowhere.jnieasy.core.method.NativeStaticMethod)jnieasyMethod).</p><p>callLong(new java.lang.Object[] </p><p>{new java.lang.Integer(a),new java.lang.Integer(b)}); </p><p>}</p><p>. . .</p><p>}</p><p>A simple invocation example:</p><p>long res = MyCPPClassOnDLLGen.addStatic(1,2);</p><p>System.out.println("Must be 3: " + res);</p><p>The varargsEx method is interesting because contains a &#8220;varargs&#8221; parameter, in this example the dec attribute is used to illustrate the &#8220;Object...&#8221; declaration following the Java 5 notation; this expression declares the parameter as &#8220;varargs&#8221; with type Object[]. This declaration is equivalent to declare the parameter with class=&#8221;Object[]&#8221; and varargs=&#8221;true&#8221; .</p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s08.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s10.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Enhancer </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Direct memory manipulation</td></tr></table></div></body></html>
