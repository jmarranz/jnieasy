<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Introduction</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title=""><link rel="up" href="index.html" title=""><link rel="prev" href="index.html" title=""><link rel="next" href="ar01s03.html" title="considerations"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Introduction</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s03.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id515352"></a>Introduction</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id515355"></a>The Problem</h3></div></div></div><p>&#8220;What platform and/or language can I use for my new application?&#8221; This is a typical question before starting a new development project. Of course there are many options, but if you go through mature and quality roads there are not so much options. </p><p>Java is a prominent and successful language and platform, and perhaps the dominant platform today to develop enterprise-quality applications. Java promises full portability around platforms following the WORA (Write Once Run Anywhere) mantra of Sun.</p><p>Anyway, Java is not alone, Java runs on top of well established operating systems like Windows and unixes (Linux, Mac, Solaris&#8230;), these operating systems were conceived, of course, before Java, and tons of libraries, applications and services have been developed before Java starts to shine. Sometimes the WORA is not fully possible if you must deal with the specific issues of the platform, or use well established libraries not found equivalent on Java. If your application goes beyond the typical CRUD (Create, Retrieve, Update and Delete) of a relational database using web, usually when developing desktop applications, is common to found &#8220;stopper features&#8221;, integration problems not already solved with Java. These stopper features invite to reevaluate Java as the most appropriate platform to this type of applications (C#?, C/C++?, Windows only tools?, Gtk+?, Qt?). Another scenario is an old but mature application developed in C/C++, the cost of a full rewrite in Java may be enormous, another option is to extend the application following the successful Java route.</p><p>Java offers a path to deal with the platform: the JNI (Java Native Interface). The JNI is a C/C++ API working as a gate to/from Java. </p><p>But JNI has many problems: </p><div class="orderedlist"><ol type="1"><li><p>Is a C/C++ based API, new skills needed.</p></li><li><p>Hard to learn, code, read and maintain.</p></li><li><p>Error prone (inherent problems of &#8220;native compiled&#8221; languages). </p></li><li><p>Memory issues (memory leaks, crashes).</p></li><li><p>Data conversions.</p></li><li><p>Strange double modeling: Java classes are object oriented, the JNI methods are not and must deal with C and C++ structures and classes. Synchronization issues.</p></li><li><p>Reduction of Java code in favor of native code: portability issues.</p></li><li><p>Java classes with native methods and C++ &#8220;glue code&#8221; usually are not object oriented. </p></li><li><p>Establishment of two development/deployment environments (IDEs, configurations &#8230;): Java and C/C++.</p></li></ol></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id354168"></a>The JNIEasy/Java Native Objects solution</h3></div></div></div><p>JNIEasy is a new JNI, Java Native Interface, but with no C/C++ code. This is not new; other tools have done this before, then&#8230; what is new?</p><p>JNIEasy starts a new software paradigm that we can call &#8220;Java Native Objects&#8221; or JNO. JNIEasy takes the main idea of the Java Data Objects (JDO) world to the world of native programming: transparency. </p><p>JNIEasy converts a POJO (Plain Old Java Object) into a Native Object: </p><div class="orderedlist"><ol type="1"><li><p>an object instance is equivalent to a native structure or C++ instance</p></li><li><p>a String object may be seen as a native string</p></li><li><p>an Object reference is equivalent to a native pointer</p></li><li><p>fields of a POJO class are equivalent to fields of a native structure or class</p></li><li><p>a method call in a POJO is a call of a C or C++ method </p></li><li><p>a Java method may be called from native as a callback using a method pointer without JNI conventions.</p></li><li><p>a Java object representing a native instance may free its related native memory automatically when is garbage collected reducing (or avoiding) memory leaks.</p></li></ol></div><p>All is done (as possible) without special classes/artifacts which mimic the native world, using directly String, StringBuffer, int, long, double, Method, int[], String[] user defined classes (without special data types) etc. </p><p>JNIEasy is Java centric, brings the native world to Java, not Java to the native world (the typical approach), the main purpose of transparency makes Java native programming no different to normal programming in Java. Alike JDO/Hibernate/JPA with the persistent programming, JNIEasy makes the native programming a pleasure, resolving the integration tasks with the underlying platform without JNI or C/C++ (Java access from C/C++ using JNIEasy is optional).</p><p>This &#8220;magic&#8221; is achieved using a technique typically used in JDO and AOP (Aspect Oriented Programming): bytecode enhancement (or bytecode weaving). The bytecode enhancement extends a normal compiled class with new capabilities (new code) but keeping the source code the same avoiding intrusive and disturbing artifacts used in the traditional approach to the problem. The bytecode enhancement enables the IOC (Inversion Of Control) paradigm used by the framework, to be fully transparent to the programmer; avoids the use of Java reflection making transparent native programming performant too and may be done in the command line or on class loading (simplifying the development lifecycle).</p><p>Although transparency is the main feature of JNIEasy (the &#8220;easy&#8221; level), the framework offers a very rich set of classes and interfaces to deal with the native world too. The programmer has ever the option of a fine control of the native memory or relay in the framework using Java basic data types (int, Integer, int[], String, StringBuffer, String[], Method &#8230; all of them have a &#8220;native layout&#8221; in JNIEasy), in fact, this rich model is used behind the scenes by the framework to achieve the transparency. Of course these utility classes and interfaces are Java centric too.</p><p>Does JNIEasy break the WORA promise?</p><p>Yes and no. The WORA promise is &#8220;easily&#8221; achieved using Java only and cross-platform Java libraries, but these &#8220;cross-platform&#8221; libraries are not ever developed using Java only, the popular AWT toolkit and many basic standard classes are very dependent on the platform (many native methods), why are they WORA too? because they are ported to almost any platform and work (&#8220;almost&#8221;) in the same way in all platforms. If the popular SWT toolkit (very platform dependent) was present in all Java installations, it would be considered part of the WORA. </p><p>If your project needs a special feature present in the underlying platform, do you must wait to Sun (and others) to deliver a WORA solution? , this is not reasonable and impossible if your need is an integration issue with another specific tool.</p><p>JNIEasy helps you to construct your own &#8220;native WORA in Java&#8221;: your Java code may detect the underlying platform and use a specific Java code to this platform, and offer a high level cross-platform API, your customers/users do not need to select a specific platform version of your program, because no custom DLL is needed to be delivered with your code.</p><p>JNIEasy offers several cross-platform options like the variable size primitives, for instance: a Java long can be reflected in the native side as a 32 bits, or 64 bits integer depending on the running platform (a long can hold a cross-platform address), a Java char can be a C char (1 byte), a Win32 wchar_t (2 bytes) or a gcc&#8217;s wchar_t (4 bytes) in unixes (Linux, Mac OS X, Solaris&#8230;), in a extreme a Java field can be 0 native size in a specific platform and not zero in another platform. The objective is simple: one Java layout-multiple native layouts, the multiple native layouts usually are due to the use of C macros, to achieve this type of &#8220;flexible memory selection&#8221; based on the platform JNIEasy uses a conditional &#8220;C inspired&#8221; macro system too. This macro system is used to select the appropriate name of dynamic libraries too (e.g. MSVCRT.dll on Windows and libc.so.6 on Linux, libc.dylib on Mac OS X, libc.so.1 on Solaris) or to resolve the problems of different name mangling of C++ compiler, the correct native exported name is selected using this macro system.</p><p>Never the WORA was so easy and powerful&#8230; and &#8220;so Java&#8221;&#8230;</p><p></p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s03.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> considerations</td></tr></table></div></body></html>
