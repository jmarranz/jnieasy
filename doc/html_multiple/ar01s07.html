<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Definition of user defined JAVA NATIVE METHODS AND classes</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title=""><link rel="up" href="index.html" title=""><link rel="prev" href="ar01s06.html" title="Runtime Life Cycle"><link rel="next" href="ar01s08.html" title="Enhancer"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Definition of user defined JAVA NATIVE METHODS AND classes</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s06.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s08.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id522098"></a>Definition of user defined JAVA NATIVE METHODS AND classes</h2></div></div></div>Definition of user defined JAVA NATIVE METHODS AND classes<p>The developer can define several types of user defined classes mapping native constructions: </p><div class="orderedlist"><ol type="1"><li><p>C++ classes</p></li><li><p>Structures (C and C++ based) </p></li><li><p>Unions (C and C++ based)</p></li><li><p>Wrappers of native capable arrays</p></li><li><p>Wrappers of multidimensional arrays (arrays of arrays)</p></li><li><p>Pointer types (wrappers of pointers) </p></li><li><p>Direct callbacks</p></li></ol></div><p>Any other native construction is solved with a predefined class of the framework, in fact, the user defined array wrappers and pointer classes are not needed at all because generic predefined classes are used by the framework to wrap the contained elements, but user defined classes of these types enable the developer to avoid castings mainly.</p><p>The user defined classes must be enhanced to be used by the framework using a XML descriptor (describing the &#8220;native view&#8221; of the class); the enhancement converts them in native capable classes. This enhancement can be made before using in runtime or &#8220;on class loading&#8221;, in this last case the XML descriptor must be present alongside the .class file. </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id522199"></a>C++ classes, structures, unions and C Methods</h3></div></div></div>C++ classes, structures, unions and C Methods<p>C++ classes, structures and unions are basically the same in C++ and in JNIEasy&#8217;s Java classes: they can have fields, constructors, methods, and inheritance (except unions). C methods or C++ static methods are basically the same: they can be mapped with Java methods inside (of course) Java classes. </p><p>In JNIEasy a user defined native capable class is a normal Java class, a POJO; this class can have declared native elements: fields, methods and a base class. A declared native element must use native enabled types and must be declared in XML as native (or declared by default as native like fields), elements not declared as native are not managed by the framework and do not have a &#8220;native correspondence&#8221;. Example: a non-native field is not reflected in native memory, a non-native method is not a proxy of a DLL method or exported to the native world as a native callback.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id522241"></a>Declaring native fields</h4></div></div></div><p>The MyStructure class seen before is an example of a simple C/C++ structure in Java:</p><p>package examples.manual;</p><p></p><p>import com.innowhere.jnieasy.core.*;</p><p>import com.innowhere.jnieasy.core.data.*;</p><p>import com.innowhere.jnieasy.core.factory.*;</p><p>import com.innowhere.jnieasy.core.mem.*;</p><p></p><p>public class MyStructure</p><p>{</p><p>protected int anInt = -1;</p><p>protected NativeIntegerArray intArr1; </p><p>// Declared "by pointer" length undefined</p><p>protected NativeIntegerArray intArr2; </p><p>// Declared "by value" length 2</p><p>protected int[] intArr3 = new int[]{5,6}; </p><p>// Declared "by pointer" length 2 </p><p>protected int[] intArr4 = new int[]{7,8}; </p><p>// Declared "by value" length 2 </p><p></p><p>public MyStructure()</p><p>{</p><p>NativeCapableFactory factory = </p><p>JNIEasy.get().getNativeCapableFactory();</p><p>intArr1 = (NativeIntegerArray)factory.wrapValue(new int[]{1,2});</p><p>intArr2 = (NativeIntegerArray)factory.wrapValue(new int[]{3,4});</p><p>} </p><p>...</p><p>}</p><p></p><p>The XML enhancer descriptor may be:</p><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p><p>&lt;!-- Archive MyStructure.jnieasy.enh.xml --&gt;</p><p>&lt;jniEasyEnhancer version="1.1"&gt;</p><p>&lt;package name="examples.manual"&gt;</p><p>&lt;imports /&gt; </p><p>&lt;class name="MyStructure" type="structure"&gt;</p><p>&lt;field name="intArr2" varConv="byValue" length="2" /&gt;</p><p>&lt;field name="intArr3" length="2" /&gt; </p><p>&lt;field name="intArr4" varConv="byValue" length="2" /&gt; </p><p>&lt;/class&gt;</p><p>&lt;/package&gt; </p><p>&lt;/jniEasyEnhancer&gt;</p><p>Note the absence of declarations of anInt and intArr1 fields, in a XML enhancer descriptor all instance fields are considered as native by default (unless explicitly excluded or qualified with the transient keyword), and default configurations are valid to these fields: primitives do not need special native information, and object based fields are declared &#8220;byPointer&#8221; by default and array fields &#8220;byPointer&#8221; have undefined length by default.</p><p>The code of instance methods is ever enhanced and managed by the framework to detect any use of native declared instance fields (to synchronize with the native memory). If the following method was added to MyStructure: </p><p>public void addToAnInt(int value)</p><p>{</p><p>this.anInt = this.anInt + value;</p><p>}</p><p></p><p>This method increments the related native memory with value without dependence of the current value of anInt field, because inside &#8220;= this.anInt +&#8221; part, the this.anInt access makes a transparent read of the native memory and updates the field before the addition, then its value is added to value and finally the temporal result is set to the anInt field (&#8220;this.anInt = &#8230;&#8221;) updating the native memory too. The &#8220;this.&#8221; qualification is optional in this example (used to enforce the idea of using the field). </p><p>The previous method body is equivalent (and works the same), to:</p><p>this.anInt += value;</p><p>Because in the bytecode level there is no difference (the += operator is expanded).</p><p>Out of the enhanced Java class the fields are accessed without management/interception and native memory is not involved; encapsulation of any external access to the fields with get/set methods is strongly encouraged to encapsulate any external access to the fields with get/set methods.</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id522522"></a>How select the appropriate native enabled type of fields starting with a real C/C++ native class/structure/union</h5></div></div></div>How select the appropriate native enabled type of fields starting with a real C/C++ native class/structure/union<p>In this manual, most of the time, &#8220;real&#8221; C/C++ constructions and types and ignored, because any valid JNIEasy construction, usually using Java primitive types, String, StringBuffer, arrays of these types, and user defined classes with methods and fields using these types, has a corresponding C/C++ construction and the opposite. Because the Java centric nature of JNIEasy, the developer must select the Java type matching the C/C++ type using the JNI definitions of the target platform. Example: in a 32 bit platform the jint type is the C int type, jint of course matches ever with the Java int type, the C char type matches with the Java byte type, a C int[] array (or int* pointing an array) matches with Java int[] and so on<sup>[<a name="id522559" href="#ftn.id522559">3</a>]</sup>. The developer has the option to use NativeIntegerArray instead of int[] , for instance, to take more control of the native management, int[] and NativeIntegerArray are interchangeable, same is applied to any other pair of &#8220;can be native&#8221; class and native capable wrapper. </p><p>In a 32 bit platform the matched C++ structure and initialization of MyStructure would be:</p><p>// MyStructure.h</p><p>struct MyStructure</p><p>{</p><p>int anInt;</p><p>int* intArr1;</p><p>int intArr2[2];</p><p>int* intArr3;</p><p>int intArr4[2];</p><p></p><p>MyStructure()</p><p>{</p><p>anInt = -1;</p><p>intArr1 = new int[2];</p><p>intArr1[0] = 1; intArr1[1] = 2;</p><p>intArr2[0] = 3; intArr2[1] = 4;</p><p>intArr3 = new int[2];</p><p>intArr3[0] = 5; intArr3[1] = 6;</p><p>intArr4[0] = 7; intArr4[1] = 8;</p><p>}</p><p>};</p><p></p><p>A C/C++ program accessing a MyStructure C/C++ structure with a MyStructure* pointer could access the native memory created with a native instance of the Java version or an object created on the native side could be accessed from Java attaching a MyStructure Java object to the address. </p><p>JNIEasy supports the &#8220;by value&#8221; convention to pass as a method parameter a structure, class, union or array (the last is not supported by C/C++ but may be useful to the developer in special cases). When using the &#8220;by value&#8221; convention the native memory of the formal parameter (the receiver) is a copy of the original argument value; in the structure, class or union cases the constructors of the copy are not invoked and virtual methods may be not valid, but non-virtual methods and fields can be accessed.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id522691"></a>Memory alignment </h5></div></div></div><p>The memory alignment of structures/classes/unions is not an issue unless specific alignment rules are used in C/C++ declarations (using #pragma pack or __declspec(align(N)) in MSVC<sup>[<a name="id522702" href="#ftn.id522702">4</a>]</sup>, and __attribute__((aligned(N))) in gcc). </p><p>To know the alignment of a C/C++ data type, the expressions __alignof__(type) in gcc and __alignof(type) in MSVC, can be used.</p><p>To know how a C++ instance field is aligned use the following macro:</p><p>#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1300) &amp;&amp; defined(__cplusplus)</p><p># define FIELD_ALIGNMENT(type, field) __alignof(((type*)0)-&gt;field)</p><p>#elif defined(__GNUC__)</p><p># define FIELD_ALIGNMENT(type, field) __alignof__(((type*)0)-&gt;field)</p><p>#else</p><p>/* FIXME: Not sure if is possible to do without compiler extension */</p><p>#endif</p><p>Several methods can be used to obtain alignment info of JNIEasy&#8217;s native elements:</p><div class="orderedlist"><ol type="1"><li><p>NativeTypeManager.alignSizeOf(Class) : returns the preferred alignment size declared in the specified native enabled class.</p></li><li><p>TypeNative.preferredAlignSize() : returns the preferred alignment size of the native type.</p></li><li><p>NativeClassDescriptor.alignSize() : returns the effective alignment size of a structure type.</p></li><li><p>NativeFieldStructureDescriptor.alignSize() : returns the effective alignment size of a concrete structure (class, union) field. </p></li></ol></div><p>JNIEasy has four levels to control the memory alignment:</p><div class="orderedlist"><ol type="1"><li><p>Global alignment specification</p></li></ol></div><p>The method NativeTypeManager.setStructureAlignSize(long) can be used to set the default memory alignment of structures, classes and unions; this value is imposed if lower than the preferred alignment of any field.</p><p>The method NativeTypeManager.getStructureAlignSize() can be used to get the current default alignment size. The default value is 8 bytes.</p><div class="orderedlist"><ol type="1"><li><p>Per structure alignment</p></li></ol></div><p>Using the optional XML enhancer attribute alignSize in the class declaration. </p><p>Example: </p><p>&lt;class name="MyStructure2" type="structure" alignSize="4"&gt; ...</p><div class="orderedlist"><ol type="1"><li><p>Per field alignment</p></li></ol></div><p>Using the optional XML enhancer attribute alignSize in the field declaration. </p><p>Example: </p><p>&lt;field name="someField" alignSize="1"&gt; ...</p><p>Another option is the prefAlignSize XML attribute of primitive types, this attribute is explained in the chapter Cross-platform options and XML attributes of Primitive types.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id522911"></a>Contiguous fields declared as unions (nested anonymous unions)</h5></div></div></div><p>Besides user defined capable classes working as unions, several contiguous fields can be grouped forming an anonymous union, the memory of union fields is shared. </p><p>A C example:</p><p>struct Dimension</p><p>{</p><p>int type;</p><p>union</p><p>{</p><p>int x;</p><p>double y;</p><p>};</p><p>const char* desc;</p><p>};</p><p>The symmetric Java class:</p><p>package examples.manual;</p><p></p><p>public class Dimension</p><p>{</p><p>protected int type;</p><p>protected int x; // start union</p><p>protected double y; // end union</p><p>protected String desc; </p><p>... /* constructors, get/set methods etc */</p><p>}</p><p>To declare x and y fields forming an anonymous union, the attribute union with values begin/end must be used in the XML:</p><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p><p>&lt;!-- Archive Dimension.jnieasy.enh.xml --&gt;</p><p>&lt;jniEasyEnhancer version="1.1"&gt;</p><p>&lt;package name="examples.manual"&gt;</p><p>&lt;imports /&gt; </p><p>&lt;class name="Dimension" type="structure"&gt;</p><p>&lt;field name="x" union="begin" /&gt; </p><p>&lt;field name="y" union="end" /&gt; </p><p>&lt;/class&gt;</p><p>&lt;/package&gt; </p><p>&lt;/jniEasyEnhancer&gt;</p><p>Java &#8220;verification&#8221;:</p><p>NativeTypeManager typeMgr = JNIEasy.get().getTypeManager();</p><p>NativeMultipleFieldContainerDescriptor classDesc = </p><p>(NativeMultipleFieldContainerDescriptor)typeMgr.getClassDescriptor(</p><p>Dimension.class);</p><p>NativeFieldStructureDescriptor xField = </p><p>(NativeFieldStructureDescriptor)classDesc.getField("x");</p><p>NativeFieldStructureDescriptor yField = </p><p>(NativeFieldStructureDescriptor)classDesc.getField("y"); </p><p>System.out.println("Must be 8 (double): " + xField.size()); </p><p>System.out.println("Must be 8 (double): " + yField.size());</p><p>System.out.println("Must be true : " + (xField.getOffset() ==</p><p> yField.getOffset()));</p><p>Recommendation: if a native capable object with union fields is going to be made native owning the native memory, is highly recommended make it native explicitly before setting any field. The explanation is: when an object is made native owning the native memory the current field values are used to set the native memory in the creation process; the framework has no way to detect in a non native object what fields was and was not set, the latest union field set the native memory state.</p><p>Wrong example!!:</p><p>Dimension dim = new Dimension();</p><p>dim.setX(10); // No native memory is set (is non-native)</p><p>JNIEasy.get().getNativeManager().makeNative(dim); </p><p>// BAD!!!! "y" field with 0 overwrites the "x" field value set </p><p>// in the native memory !</p><p>System.out.println("Must be true : " + (dim.getX() == 0));</p><p>Correct example:</p><p>Dimension dim = new Dimension();</p><p>JNIEasy.get().getNativeManager().makeNative(dim); </p><p>dim.setX(10); // Sets the native memory too</p><p>System.out.println("Must be true : " + (dim.getX() == 10));</p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id523192"></a>Declaring Java methods working as proxy of native methods</h4></div></div></div><p>Methods of Java classes declared as structures, C++ classes or unions can be declared as proxy of C/C++ methods. </p><p>C++ methods fit very well with Java methods (instance or static), what about C methods?, there are two options to map Java static methods working as proxies of C methods: use the code generation utilities (see Java Code Generation), or declare a Java class declared as a (false non-existing) native C++ class and put inside the static Java methods working as proxy of C methods; these &#8220;false&#8221; native Java classes usually are very useful to group the C methods by categories.</p><p>A C++ class example (valid with MSVC and gcc compilers<sup>[<a name="id523227" href="#ftn.id523227">5</a>]</sup>):</p><p>// MyCPPClassOnDLL.h</p><p>class DLLEXPORT MyCPPClassOnDLL</p><p>{</p><p>protected:</p><p>double m_value;</p><p>public:</p><p>MyCPPClassOnDLL(int a,int b);</p><p></p><p>static MyCPPClassOnDLL* __stdcall create(int a,int b);</p><p></p><p>static void __stdcall destroy(MyCPPClassOnDLL* obj);</p><p></p><p>static __int64 __stdcall addStatic(int a,int b);</p><p></p><p>double __stdcall getValue();</p><p></p><p>virtual double __stdcall sub(int a,int b);</p><p></p><p>void __cdecl varargsEx(char* buffer,...);</p><p></p><p>};</p><p></p><p></p><p>// MyCPPClassOnDLL.cpp</p><p></p><p>#include "MyCPPClassOnDLL.h"</p><p>#include &lt;stdio.h&gt;</p><p></p><p>MyCPPClassOnDLL::MyCPPClassOnDLL(int a,int b)</p><p>{</p><p>m_value = a + b;</p><p>}</p><p></p><p>MyCPPClassOnDLL* __stdcall MyCPPClassOnDLL::create(int a,int b)</p><p>{</p><p>return new MyCPPClassOnDLL(a , b); // may be an inherited class</p><p>}</p><p></p><p>void __stdcall MyCPPClassOnDLL::destroy(MyCPPClassOnDLL* obj)</p><p>{</p><p>delete obj;</p><p>}</p><p></p><p>__int64 __stdcall MyCPPClassOnDLL::addStatic(int a,int b)</p><p>{</p><p>return (__int64)a + (__int64)b;</p><p>}</p><p></p><p>double __stdcall MyCPPClassOnDLL::getValue()</p><p>{</p><p>return m_value;</p><p>}</p><p></p><p>double __stdcall MyCPPClassOnDLL::sub(int a,int b)</p><p>{</p><p>m_value = m_value - (a + b);</p><p>return m_value;</p><p>}</p><p></p><p>void __cdecl MyCPPClassOnDLL::varargsEx(char* buffer,...)</p><p>{</p><p>va_list marker;</p><p>va_start( marker, buffer );</p><p>const char* name = va_arg( marker, const char*);</p><p>int age = va_arg( marker, int);</p><p>int brothers = va_arg( marker, int);</p><p>va_end( marker );</p><p></p><p>sprintf(buffer,"%s is %d years old and has %d brothers",name,age,</p><p>brothers);</p><p>}</p><p>If used a Linux/Mac/Solaris gcc compiler, __int64, __cdecl and __stdcall keywords valid with Win32 compilers (MSVC, MinGW gcc, cygwin gcc), are defined in JNIEasy.h as:</p><p>#define __cdecl __attribute__((cdecl))</p><p>#define __stdcall __attribute__((stdcall))</p><p>typedef long long __int64;</p><p></p><p>The DLLEXPORT (__declspec(dllexport) in Win32 compilers) macro, exports all methods and static fields of the class, this modifier can be used in a per method (and static field) basis. In Visual C++ 6 and gcc 32 bit compilers the presence of a virtual method (the sub method) adds an internal and hidden int field: the pointer to the virtual table (is added in the top most class only)<sup>[<a name="id523534" href="#ftn.id523534">6</a>]</sup>. </p><p>JNI types are not used consciously (jlong is __int64 in Windows, long long in Linux/Mac/Solaris x86) to show that JNIEasy integrates with legacy non-Java related code. </p><p>The Java class to be used as proxy:</p><p>package examples.manual;</p><p></p><p>public class MyCPPClassOnDLL</p><p>{</p><p>protected int _virtualTable; // the C++ class has a virtual method </p><p>protected double value;</p><p></p><p>public MyCPPClassOnDLL() // mandatory (is not native)</p><p>{</p><p>} </p><p></p><p>public MyCPPClassOnDLL(int a, int b)</p><p>{</p><p>throw new RuntimeException("Not enhanced"); </p><p>} </p><p></p><p>public static void destroy(MyCPPClassOnDLL obj)</p><p>{</p><p>throw new RuntimeException("Not enhanced"); </p><p>}</p><p></p><p>public static native long addStatic(int a,int b);</p><p></p><p>public double getValue() // not a proxy</p><p>{</p><p>return value;</p><p>}</p><p></p><p>public double sub(int a,int b)</p><p>{ </p><p>throw new RuntimeException("Not enhanced");</p><p>}</p><p></p><p>public static void varargsEx(byte[] buffer,Object[] args)</p><p>{</p><p>throw new RuntimeException("Not enhanced"); </p><p>}</p><p>}</p><p></p><p>JNIEasy supports two forms to declaring a Java native method: </p><p>public static void destroy(MyCPPClassOnDLL obj)</p><p>{</p><p>throw new RuntimeException("Not enhanced"); </p><p>}</p><p></p><p>public static native long addStatic(int a,int b);</p><p>The body of the first method will be replaced by the enhanced one and a new body will be added to the second method removing the native modifier. If the specified RuntimeException exception is thrown or a standard Java linker exception is thrown (trying to link the native method) are signs telling us the class was not enhanced, the enhancement process replaces the provided default body and removes the native flag if present.</p><p>The XML enhancer descriptor (MSVC exported names only):</p><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p><p>&lt;!-- Archive MyCPPClassOnDLL.jnieasy.enh.xml --&gt;</p><p>&lt;jniEasyEnhancer version="1.1"&gt;</p><p>&lt;package name="examples.manual"&gt;</p><p>&lt;imports/&gt; </p><p>&lt;class name="MyCPPClassOnDLL" type="class" </p><p>libraryPath="MyLibrary" &gt;</p><p></p><p>&lt;constructor onLibrary="true" </p><p>nativeName="?create@MyCPPClassOnDLL@@SGPAV1@HH@Z"</p><p> params="int, int" &gt;</p><p>&lt;/constructor&gt; </p><p></p><p>&lt;method name="destroy" onLibrary="true" </p><p>nativeName="?destroy@MyCPPClassOnDLL@@SGXPAV1@@Z"</p><p> params="MyCPPClassOnDLL"&gt;</p><p>&lt;/method&gt;</p><p></p><p>&lt;method name="addStatic" onLibrary="true" </p><p>nativeName="?addStatic@MyCPPClassOnDLL@@SG_JHH@Z"&gt;</p><p>&lt;return /&gt; </p><p>&lt;params params="int, int" /&gt; </p><p>&lt;/method&gt;</p><p></p><p>&lt;method name="sub" onLibrary="true" </p><p>nativeName="?sub@MyCPPClassOnDLL@@UAGNHH@Z"&gt; </p><p>&lt;return /&gt; </p><p>&lt;params&gt; </p><p>&lt;param class="int" /&gt;</p><p>&lt;param class="int" /&gt; </p><p>&lt;/params&gt; </p><p>&lt;/method&gt; </p><p></p><p>&lt;method name="varargsEx" onLibrary="true" </p><p>nativeName="?varargsEx@MyCPPClassOnDLL@@SAXPADZZ" </p><p> callConv="c_call"&gt; </p><p>&lt;return /&gt; </p><p>&lt;params&gt; </p><p>&lt;param class="byte[]" /&gt;</p><p>&lt;param class="Object[]" varargs="true" /&gt; </p><p>&lt;/params&gt; </p><p> &lt;/method&gt;</p><p></p><p>&lt;/class&gt; </p><p>&lt;/package&gt; </p><p>&lt;/jniEasyEnhancer&gt;</p><p>The XML descriptor declares the constructor with two parameters, the addStatic, sub and varargsEx methods as proxies of the corresponding exported methods of the C++ class. The class declares the DLL to be used with the libraryPath attribute (a hypothetical MyLibrary.dll or libMyLibrary.so or libMyLibrary.dylib), the .dll, .so and .dylib extensions and the UNIX &#8220;lib&#8221; prefix may be omitted following the same rules as the System.loadLibrary Java method. </p><p>The onLibrary="true" declares a method as proxy (otherwise is a callback, the default) of a native method and the nativeName attribute declares the exported name of the DLL method to link<sup>[<a name="id523976" href="#ftn.id523976">7</a>]</sup>. Several tools can be used to obtain the native name of a DLL/shared object&#8217;s exported method or field, in Windows use the free tool PEDUMP<sup>[<a name="id523992" href="#ftn.id523992">8</a>]</sup> (included inside the distribution), on Linux use objdump (with --dynamic-syms argument), with Mac use nm, and on Solaris use elfdump (-s argument). On Linux, Mac and Solaris c++filt command does the reverse task: demangles an exported name showing the C/C++ original header (very useful in C++), in Windows Microsoft provides a special method UnDecorateSymbolName<sup>[<a name="id524013" href="#ftn.id524013">9</a>]</sup> and the command undname included in the Microsoft SDK.</p><p>To specify what method/constructor is being enhanced, JNIEasy supports three syntaxes:</p><p>1) &lt;constructor/method params="class,class,..." &gt;</p><p></p><p>2) &lt;method ...&gt;</p><p>&lt;return /&gt; </p><p>&lt;params params="class,class,..." /&gt; </p><p>&lt;/method&gt;</p><p></p><p>3) &lt;method ...&gt; </p><p>&lt;return /&gt; </p><p>&lt;params&gt; </p><p>&lt;param class="class" /&gt;</p><p>&lt;param class="class" /&gt; </p><p>&lt;/params&gt; </p><p>Only the third mode can be used to modify the default native memory layout of the parameter. For instance:</p><p>&lt;param class="Object[]" varargs="true" /&gt;</p><p>The param attribute, &lt;param&gt; nodes and the class attribute are used to pick the &#8220;real&#8221; Java class method to be used as proxy; in this example parameters with primitive types are used and the native declaration is straightforward but native information can be added to declare the native view of the parameter as a native variable with the same syntax of the &lt;field&gt; tag. The &lt;return/&gt; tag works in a similar fashion (note the class attribute is optional because the return class is known). The default constructor and getValue() method are not declared as proxy in this example, but the value field is enhanced and when the getValue() Java method is invoked the native C++ field is read too (it works as the C++ getValue() version). </p><p>If not specified the attribute callConv, the default call convention of a method is std_call, callConv valid values are std_call or c_call. The C call convention is used in the varargsEx method because methods with variable arguments only support C calls. Call convention declared in the Java side and native side must be coincident, only standard and C calls are supported by JNIEasy, any other convention like the &#8220;fast call&#8221;, the default with compilers like MSVC or gcc, is not supported.</p><p>The parameter args of the method varargsEx is declared as &#8220;variable number of arguments&#8221; (varargs), using the varargs attribute set to true. A varargs attribute mimics in Java the C &#8230; parameter convention. Without this attribute (or set to false), the default convention of the Object[] parameter type is to pass a pointer-to-array to the method, with the varargs attribute set to true, all array elements are passed as parameters to the method with the &#8220;intrinsic&#8221; native type.</p><p>A Java method working as a proxy does not need a body, because this body is overwritten in enhancement time with a new body calling the native method using an internal CPPConstructor, CMethod, CPPMethod or CFieldMethod object attached to the native C/C++ method in the DLL. A good practice is to throw a RuntimeException or inherited as method body (the enhancer removes this) to remember the class must be enhanced.</p><p>The constructor proxy is a special case because the C++ linked version must be a static method returning the pointer of a new allocated C++ object (a C++ exported constructor can not be used directly). When calling the Java proxy constructor, the address returned by the C style constructor is internally used to attach the Java instance to the native C++ object, the Java instance created with a proxy constructor is ever native and attached to the native object, and C++ virtual methods can be called because the C++ related object was created with a normal C++ constructor.</p><p>The native static method addStatic() is inside a C++ class, this is not a limitation, JNIEasy can link normal C methods, in C++ is recommendable use extern "C" to avoid the name mangling of exported C methods in C++ files (or to declare the desired name in a custom .DEF file with MSVC or similar approaches in gcc). </p><p>An example of a static method call:</p><p>byte res = MyCPPClassOnDLL.addStatic(1,2);</p><p>System.out.println("Must be 3: " + res);</p><p></p><p>Example of a complete lifecycle of a native instance:</p><p>MyCPPClassOnDLL obj = new MyCPPClassOnDLL(1,2); </p><p>// Calls create() C++ method. New object is already native</p><p>System.out.println("Must be 3: " + obj.getValue());</p><p>// Java method getValue() is not native (field &#8220;value&#8221; is native) </p><p></p><p>double res2 = obj.sub(1,2);</p><p>System.out.println("Must be 0: " + res2);</p><p></p><p>MyCPPClassOnDLL.destroy(obj); </p><p>// Calls the C++ method destroy(), the memory is freed</p><p>An example of varargs call:</p><p>byte[] buffer = new byte[256];</p><p>MyCPPClassOnDLL.varargsEx(buffer,</p><p>new Object[]{"Joe",new Integer(25),new Integer(2)});</p><p>String res = NativePrimitiveUtil.toString(buffer);</p><p>System.out.println("Must be true: " + </p><p>"Joe is 25 years old and has 2 brothers".equals(res));</p><p>The default native type of "Joe" is char*, and the default native type of Integer in a varargs context is the int data type (in any other context the related native type is int*, to use a pointer to int parameter in a varargs call, use a NativeInteger object). The method NativePrimitiveUtil.toString(byte[]) converts a byte based string ended with a 0 element in a String object (very useful to work with ANSI strings).</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id524283"></a>Declaring Java methods working as native callbacks</h4></div></div></div><p>A Java method declared as a native callback is a normal method (with a signature using native enabled types) callable from native. Selected constructors, static and instance methods in a user defined Java class, declared as a structure, C++ class or union, can be declared as native callbacks. </p><p>Example:</p><p>package examples.manual;</p><p>import com.innowhere.jnieasy.core.JNIEasy;</p><p></p><p>public class MyCPPClassOnJava</p><p>{</p><p>protected double value;</p><p></p><p>public MyCPPClassOnJava() // mandatory</p><p>{</p><p>}</p><p></p><p>public MyCPPClassOnJava(int a,int b)</p><p>{</p><p>this.value = a + b; </p><p>JNIEasy.get().getLockedRegistry().lock(this); </p><p>// To avoid GC if called from native</p><p>}</p><p></p><p>public static void destroy(MyCPPClassOnJava obj)</p><p>{ </p><p>JNIEasy.get().getLockedRegistry().unlock(obj); </p><p>// To enable GC again</p><p>JNIEasy.get().getNativeManager().free(obj);</p><p>} </p><p></p><p>public static long addStatic(int a,int b)</p><p>{</p><p>return (long)a + (long)b;</p><p>}</p><p></p><p>public double sub(int a,int b)</p><p>{ </p><p>this.value = this.value - (a + b);</p><p>return this.value;</p><p>} </p><p>}</p><p>The XML enhancer descriptor:</p><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p><p>&lt;!-- Archive MyCPPClassOnJava.jnieasy.enh.xml --&gt;</p><p>&lt;jniEasyEnhancer version="1.1"&gt;</p><p>&lt;package name="examples.manual"&gt;</p><p>&lt;imports /&gt; </p><p>&lt;class name="MyCPPClassOnJava" type="class"&gt;</p><p>&lt;constructor exportMethod="true" params="int,int" &gt;</p><p>&lt;/constructor&gt; </p><p>&lt;method name="destroy" exportMethod="true" </p><p>params="MyCPPClassOnJava"&gt;</p><p>&lt;/method&gt; </p><p>&lt;method name="addStatic" exportMethod="true"</p><p>params="int,int"&gt;</p><p>&lt;/method&gt; </p><p>&lt;method name="sub" exportMethod="true" params="int,int"&gt;</p><p>&lt;/method&gt;</p><p>&lt;/class&gt;</p><p>&lt;/package&gt;</p><p>&lt;/jniEasyEnhancer&gt;</p><p>The constructor&#8217;s sentence: JNIEasy.get().getLockedRegistry().lock(this); inserts the object with a normal reference in the framework&#8217;s lock registry to avoid the garbage collector to collect the instance. Why? because a Java instance created from native code does not retain the object with a Java reference (the native call returns a native pointer not a Java reference), after object construction, the object goes out the scope and the garbage collector can free the instance (freeing the allocated native memory) any time; the lock action prevents the GC to free the instance. The method working as a &#8220;destructor&#8221; unlocks the object, if there is no Java reference pointing the instance it is marked to be garbage collected (an asynchronous &#8220;delete&#8221;).</p><p>If the Java object is created from native side, a &#8220;real&#8221; Java object is created and made native allocating native memory. But if the Java object is created from Java with a normal new, no native memory is allocated and the callback methods work as normal; like a native capable Java object it can be made native (allocating or attaching) in any time, and in this state, native fields are synchronized with the native memory.</p><p>There are two ways to call Java callbacks from native:</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id524580"></a>Using the internal native method instances</h5></div></div></div><p>A &#8220;native descriptor&#8221; of a user defined native capable class can be obtained with the method: NativeTypeManager.getClassDescriptor(Class) </p><p>Example:</p><p>NativeTypeManager typeMgr = JNIEasy.get().getTypeManager();</p><p>NativeMultipleFieldContainerDescriptor classDesc = </p><p>(NativeMultipleFieldContainerDescriptor)typeMgr.getClassDescriptor(</p><p>MyCPPClassOnJava.class);</p><p>Constructor construc = MyCPPClassOnDLL.class.getDeclaredConstructor(</p><p>new Class[]{int.class,int.class});</p><p>NativeConstructorDescriptor constrDesc = </p><p>(NativeConstructorDescriptor)classDesc.getBehavior(construc);</p><p>NativeConstructor natConstr = constrDesc.getNativeConstructor();</p><p>The natConstr object is the native constructor instance &#8220;making native&#8221; the MyCPPClassOnJava constructor with two int parameters. This native object can be submitted to the native side as a pointer to method.</p><p>By default the native method instances are &#8220;direct&#8221; (natConstr is a NativeDirectConstructorCallback instance in this case), but the optional useReflection=&#8221;true&#8221; attribute (by default is false) can be added to use the reflection version (NativeConstructorReflection in this case). Example:</p><p>&lt;constructor exportMethod="true" useReflection="true" </p><p>params="int,int" &gt;</p><p>&lt;/constructor&gt; </p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id524679"></a>Dynamic linking Java methods from C/C++ side querying the addresses with the exported signature.</h5></div></div></div><p>Exists a C method findExportedMethodAddress exported by the JNIEasy DLL.</p><p></p><p>void* __stdcall findExportedMethodAddress(const char* signature)</p><p>Where __stdcall is defined in JNIEasy.h with a valid compiler-dependent declaration.</p><p>This method returns the address of the method registered in the framework with the specified signature. Any method registered with DynamicLibrary methods are automatically exported and accessible using findExportedMethodAddress using the following syntax:</p><p>"[DLLName:]MethodSignature"</p><p>Where the optional DLLName is the name used to get the DynamicLibrary object from DLLManager.get(String) the first time; MethodSignature follows a mixed Java/C++ syntax, this syntax is explained in the javadoc documentation of the method NativeBehaviorSignature.getSignatureString(String).</p><p>The method findExportedMethodAddress(const char*) is equivalent to the Java method JNIEasyLibrary.findExportedMethodAddress(String signature) (in fact this method is called), this method parses the DLLName, if declared, and calls DynamicLibrary.findBehaviorBySignature(String) using the DynamicLibrary object associated to the specified DLL with DLLName. Example:</p><p>String sig = ...</p><p>NativeBehavior cb =</p><p>JNIEasy.get().getJNIEasyLib().findExportedMethodAddress(sig);</p><p>If no method was registered with the specified signature returns null.</p><p>If the DLL name is omitted the JNIEasy&#8217;s DLL is supposed, this applies to Java methods as native callbacks, the XML exportMethod="true" attribute specifies that the internally used native method object to make native the Java method declared as callback, is exported and accessible with findExportedMethodAddress, the native method object is registered with JNIEasyLibrary.exportBehavior(String nativeName,NativeBehavior method) using the Java method name as the first parameter (if the method is static the absolute class name is added as prefix and with constructors the "&lt;init&gt;" name is ever used).</p><p>Any DLL exported method can be found calling findExportedMethodAddress(const char*) from native if the exported method was previously registered using an appropriated DynamicLibrary method, this &#8220;dynamic binding&#8221; technique is an alternative to the classic LoadLibrary/GetProcAddress in Windows and dlopen/dlsym in UNIXes, the main difference is Java exported callbacks can be obtained too (they are &#8220;simulated&#8221; exported native methods by JNIEasy DLL).</p><p>The findExportedMethodAddress method is declared in the JNIEasy.h public framework file and can be statically linked using JNIEasy.lib with MSVC. Is exported by the JNIEasy DLL with the method name "findExportedMethodAddress" and can be dynamically linked (in Win32 using LoadLibrary/GetProcAddress in Windows and dlopen/dlsym in Linux/Mac/Solaris). The files JNIEasy.c and JNIEasyHelper.cpp are provided to help the dynamic linking process (both files and JNIEasy.h can be found in the include folder). If findExportedMethodAddress is not used your native code has no dependency with JNIEasy (useful macros like DLLEXPORT are not directly related with JNIEasy and can be easily copied in your code for your convenience).</p><p>The Java class exports the specified callback methods when is loaded and initialized, to ensure a class is loaded and initialized this utility method can be used<sup>[<a name="id524807" href="#ftn.id524807">10</a>]</sup>:</p><p>NativeCapableUtil.initializeClass(MyCPPClassOnJava.class);</p><p>or calling NativeTypeManager.getClass(String) with the class name, the ClassLoader currently defined in JNIEasy will be used to load and initialize the class:</p><p>JNIEasy.get().getTypeManager().getClass("examples.manual.MyCPPClassOnJava");</p><p>Following with the example, the signatures of the exported MyCPPClassOnJava callbacks are:</p><p>"examples.manual.MyCPPClassOnJava.&lt;init&gt;(int,int)"</p><p>"examples.manual.MyCPPClassOnJava.destroy(examples.manual.MyCPPClassOnJava*)"</p><p>"examples.manual.MyCPPClassOnJava.addStatic(int,int)"</p><p>"examples.manual.MyCPPClassOnJava.sub(int,int)"</p><p>To understand how these signatures are constructed see the javadoc of JNIEasyLibrary.exportBehavior(String nativeName,NativeBehavior method)</p><p>A C++ class ready to work as a proxy of the Java class may be:</p><p>// MyCPPClassOnJava.h</p><p></p><p>#include &lt;JNIEasy.h&gt;</p><p>#include &lt;JNIEasyHelper.h&gt;</p><p></p><p>class MyCPPClassOnJava</p><p>{</p><p>protected:</p><p>static void* (__stdcall * _MyCPPClassOnJava)(int,int);</p><p>static void (__stdcall * _destroy)(void*);</p><p>static __int64 (__stdcall * _addStatic)(int,int);</p><p>static double (__stdcall * _sub)(void*,int,int);</p><p>public:</p><p>static MyCPPClassOnJava* create(int a,int b)</p><p>{</p><p>if (_MyCPPClassOnJava == 0)</p><p>_MyCPPClassOnJava = (void* (__stdcall *)(int,int)) </p><p>JNIEasyHelper::findExportedMethodAddress(</p><p> "examples.manual.MyCPPClassOnJava.&lt;init&gt;(int,int)");</p><p>return (MyCPPClassOnJava*)_MyCPPClassOnJava(a,b);</p><p>}</p><p></p><p>static void destroy(MyCPPClassOnJava* obj)</p><p>{ </p><p>if (_destroy == 0)</p><p>_destroy = (void (__stdcall *)(void*))</p><p>JNIEasyHelper::findExportedMethodAddress(</p><p>"examples.manual.MyCPPClassOnJava.destroy(</p><p>examples.manual.MyCPPClassOnJava*");</p><p>_destroy(obj);</p><p>}</p><p></p><p>static __int64 addStatic(int a,int b)</p><p>{</p><p>if (_addStatic == 0)</p><p>_addStatic = (__int64 (__stdcall *)(int,int)) </p><p>JNIEasyHelper::findExportedMethodAddress(</p><p>"examples.manual.MyCPPClassOnJava.addStatic(int,int)"); </p><p>return _addStatic(a, b);</p><p>}</p><p></p><p>double sub(int a,int b)</p><p>{ </p><p>if (_sub == 0)</p><p>_sub = (double (__stdcall *)(void*,int,int)) </p><p>JNIEasyHelper::findExportedMethodAddress(</p><p>"examples.manual.MyCPPClassOnJava.sub(int,int)");</p><p>return _sub(this, a, b);</p><p>}</p><p>};</p><p></p><p>// MyCPPClassOnJava.cpp</p><p>#include "MyCPPClassOnJava.h"</p><p></p><p>void* (__stdcall * MyCPPClassOnJava::_MyCPPClassOnJava)(int,int) = 0;</p><p>void (__stdcall * MyCPPClassOnJava::_destroy)(void*) = 0;</p><p>__int64 (__stdcall * MyCPPClassOnJava::_addStatic)(int,int) = 0;</p><p>double (__stdcall * MyCPPClassOnJava::_sub)(void*,int,int) = 0;</p><p>Example of use:</p><p>MyCPPClassOnJava* proxy = MyCPPClassOnJava::create(2,3); </p><p>// like a Java: new MyCPPClassOnJava(2,3);</p><p>double res = proxy-&gt;sub(2,3); // Must be 0</p><p>MyCPPClassOnJava::destroy(proxy); // Unlock the Java object </p><p>C++ objects created as proxy of Java objects (using the Java constructor) are not created with the normal C++ new sentence, the Java side allocates the native memory, then the C++ delete sentence must not be used to destroy a Java allocated object (the C++ new was not used), the Java native instance will free the native memory.</p><p>Of course a C++ object can be constructed with a normal C++ constructor. Following the example:</p><p>// MyCPPClassOnJava.h</p><p>class MyCPPClassOnJava</p><p>{</p><p>protected:</p><p>double m_value; // the same as in Java class</p><p>. . .</p><p>public:</p><p>MyCPPClassOnJava(int a,int b) // the same as in Java class</p><p>{</p><p> m_value = a + b;</p><p>}</p><p>. . .</p><p>};</p><p></p><p>Example of use:</p><p>MyCPPClassOnJava* proxy = new MyCPPClassOnJava(2,3);</p><p>double res = proxy-&gt;sub(2,3); // Must be 0</p><p>delete proxy; </p><p>This example do the same as the previous, but it works in a different manner: only the method sub is working as proxy and calling the related Java method, when invoking, a temporal MyCPPClassOnJava Java instance is created and attached to the address of the C++ object and the Java sub method is called, the Java field value accessed inside the method is synchronized with the native memory, the read/write change of the Java field is performed with the native memory field, the returned value is the expected. This operational mode (allocating memory in the C++ side) is not performant because a new Java instance is created and attached to native object address in a per C++ proxy/Java method call basis, the temporal Java instance is discarded in the end of call. The other operational mode, calling a Java constructor (allocating memory in the Java side) is more performant because the Java instance is unique it is internally registered as a native memory owner (reminder: this registry does not hold the object with a strong reference) and locked in the constructor (with a strong reference). </p><p>A note about Mac OS X 10.4 (Tiger) gcc 4.0 and findExportedMethodAddress: gcc on Mac makes aggressive optimizations using the flag -Ox (x != 0), for instance the &#8220;omit-frame-pointer&#8221; optimization. A call to findExportedMethodAddress enters inside the Java VM, if you are experimenting strange problems try to add -fno-omit-frame-pointer to the gcc compiler options or remove the &#8211;Ox flag. </p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id525274"></a>Java fields working as native field (method) callbacks</h5></div></div></div><p>The Java fields, static or instance, of native capable classes are a special case of callbacks. A non-native Java field can be wrapped, made native and exported to the native world with a related field-method callback created by the framework behind the scenes.</p><p>To do this, is necessary to add a &lt;fieldMethod&gt; declaration in the XML enhancer file, declaring the field name and the native type declaration of the field type.</p><p>In the previous XML file MyCPPClassOnJava.jnieasy.enh.xml:</p><p>... </p><p>&lt;fieldMethod name="value" exportMethod="true" /&gt; </p><p>&lt;/class&gt;</p><p>...</p><p>The new tag declares the field value as a field-method (in this case the field is already declared native but this is not mandatory), using the default native related type of int and the standard call convention (std_call), the method is exported and can be obtained using the method findExportedMethodAddress(const char*). By default the native field-method instance is &#8220;direct&#8221; (NativeDirectInstanceFieldCallback in this case), but the optional useReflection=&#8221;true&#8221; attribute can be added to use the reflection version (NativeInstanceFieldMethodReflection in this case):</p><p>&lt;fieldMethod name="value" exportMethod="true" useReflection="true" /&gt; </p><p>The native field-method instance to be used can be obtained as any other native method with the native class descriptor, but using the java.lang.reflect.Field object of the field.</p><p>NativeTypeManager typeMgr = JNIEasy.get().getTypeManager();</p><p>CPPClassDescriptor classDesc = </p><p> (CPPClassDescriptor)typeMgr.getClassDescriptor(MyCPPClassOnJava.class);</p><p>Field field = MyCPPClassOnJava.class.getDeclaredField("value");</p><p>NativeBehaviorDescriptor methodDesc = classDesc.getBehavior(field);</p><p>If not using reflection:</p><p>NativeDirectInstanceFieldCallback callback =</p><p>(NativeDirectInstanceFieldCallback)methodDesc.getNativeBehavior(); </p><p>If using reflection:</p><p>NativeInstanceFieldMethodReflection callback =</p><p>(NativeInstanceFieldMethodReflection)methodDesc.getNativeBehavior(); </p><p>The signature to use with findExportedMethodAddress is:</p><p>"examples.manual.MyCPPClassOnJava.value(int,double)"</p><p>To use this exported method from native:</p><p></p><p>// MyCPPClassOnJava.h</p><p>class MyCPPClassOnJava</p><p>{</p><p>. . .</p><p>static double (__stdcall * _value)(void*,int,double);</p><p>. . .</p><p>double MyCPPClassOnJava::valueField(int opcode,double value)</p><p>{</p><p> if (_value == 0)</p><p>_value = (double (__stdcall *)(void*,int,double))</p><p> JNIEasy::findExportedMethodAddress(</p><p>"examples.manual.MyCPPClassOnJava.value(int,double)");</p><p></p><p> return _value(this,opcode,value);</p><p>}</p><p></p><p>};</p><p></p><p>// MyCPPClassOnJava.cpp</p><p>double (__stdcall * MyCPPClassOnJava::_value)(void*,int,double) = 0;</p><p>An example of call in C++:</p><p>MyCPPClassOnJava* proxy = ...</p><p>proxy-&gt;valueField(NativeFieldMethod::SET,10);</p><p>double res = proxy-&gt;valueField(NativeFieldMethod::GET,0); </p><p>// Must be 10</p><p>The NativeFieldMethod class (holding the GET, SET and GET_SET constants) is defined in JNIEasy.h, constants 0 (GET), 1 (SET) and 2 (GET_SET) can be used too. </p><p>Important: a native field-method callback access the related Java field directly (using a direct access or reflection), if the (instance) field is native the native memory is not read or modified. A possible new value set with the native field-method can be lost and updated with the native memory value when reading the Java field normally, and the Java field value read with the native field-method is not ensured to be synchronized with the native memory. In our example the Java field is already native and can be accessed directly from Java (using get and set methods). Is not recommended to use a Java field declared as native and accessed using a field-method (the Java field can be read/updated without the native memory synchronization)</p><p>The export of a Java field as a method is especially useful with static fields (a static field can not be declared as native directly) and non-native instance fields.</p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id525550"></a>Mixing models: a Java class working as proxy and callback </h4></div></div></div>Mixing models: a Java class working as proxy and callback <p>The proxy/callback modeling is based on methods not classes; there is no limitation to mix in the same Java class methods working as proxy and methods working as callbacks. </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id525562"></a>Inheritance</h4></div></div></div>Inheritance<p>Java native capable classes, declared as C++ classes and structures, support inheritance; they can inherit from another Java native capable class mapping the C++ tree. C++ unions do not support inheritance, this is applied to Java unions too.</p><p>In enhancement time JNIEasy automatically detects if a user defined Java native capable class inherits from another native capable class, there is no declaration in the XML descriptor. The framework ever enhances first the base native capable class locating and loading the XML descriptor of the base class, the XML file must be alongside the .class file. Is not allowed to insert in the middle of a native capable inheritance tree a non-native capable class (use a native capable class without native fields if you need something similar), but is valid to inherit from a non-native capable class as the top most base class (in fact all classes inherit from java.lang.Object).</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id525590"></a>Inheritance in Java classes working as proxies</h5></div></div></div>Inheritance in Java classes working as proxies<p>There is a limitation regarding C++ virtual methods (declared with the virtual keyword): an exported virtual method (like sub) is called from Java ignoring the virtual rule because its method address is used directly (is not obtained using the virtual method table). This is a minor limitation because the virtual behavior works in the Java side, the Java method called (supposed not final) is the most derived, and this method calls the related derived method in the C++ side.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id525607"></a>Inheritance in Java classes working as callbacks</h5></div></div></div><p>There is a limitation: C++ objects created as proxy of a Java object (using the Java constructor) are not created with the normal C++ new sentence and no C++ constructor is called, a C++ constructor initializes the virtual table of methods (if any), wherefore C++ virtual methods (declared with &#8220;virtual&#8221; keyword) can not be called. This is a minor limitation because the virtual behavior works in the Java side and the most derived method is called. Base and derived methods must be declared in the C++ proxy without the virtual keyword, regardless the C++ method called the most derived Java method is called. Of course C++ virtual methods works ok if the object is created with a new sentence invoking a normal C++ constructor.</p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id525645"></a>Inner classes</h4></div></div></div><p>Inner classes are allowed as native capable classes, but only static inner classes. The XML enhancer descriptor file must follow the same name rules as the .class file. For instance, if the MyStructure class declares a static inner class named MyInnerStructure, the XML file name must be:</p><p>MyStructure$MyInnerStructure.jnieas.enh.xml</p><p>And the XML content may be:</p><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p><p>&lt;jniEasyEnhancer version="1.1"&gt;</p><p>&lt;package name="examples.manual"&gt;</p><p>&lt;imports/&gt; </p><p>&lt;class name="MyStructure$MyInnerStructure" type="structure" /&gt; </p><p>&lt;/package&gt; </p><p>&lt;/jniEasyEnhancer&gt;</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id525700"></a>User defined native capable direct callbacks</h3></div></div></div><p>The developer can export to the native side, single Java methods with native capable signatures outside Java classes as C++ classes, structures and union. These methods, of course, must be declared inside Java classes (a Java imperative). A user defined Java class containing a native capable method may be declared as a native capable direct callback; a native instance has an address and represents a native method with a native signature callable from the native side (a pointer-to-method); in fact if the native instance is freed, explicitly or by the garbage collector, the native method can not be called from native because the method address is not valid (and can be reused by another native element). A native method instance must be seen as a native method compiled &#8220;on the fly&#8221;. Two native instances of the same class (same method) have different addresses, they must be considered like two different methods.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id525752"></a>Static callbacks</h4></div></div></div><p>A simple example with a static method:</p><p></p><p>package examples.manual;</p><p></p><p>public class AddTwoNumbersCallback</p><p>{</p><p>public static long add(int a,int b)</p><p>{ </p><p>return (long)a + (long)b;</p><p>} </p><p>}</p><p>The XML enhancer file:</p><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p><p>&lt;!-- AddTwoNumbersCallback.jnieasy.enh.xml --&gt;</p><p>&lt;jniEasyEnhancer version="1.1"&gt;</p><p>&lt;package name="examples.manual"&gt;</p><p>&lt;imports /&gt; </p><p>&lt;class name="AddTwoNumbersCallback" type="callback" &gt;</p><p>&lt;method name="add" params="int,int" &gt;</p><p>&lt;/method&gt;</p><p>&lt;/class&gt;</p><p>&lt;/package&gt;</p><p>&lt;/jniEasyEnhancer&gt;</p><p>The signature in the C/C++ side may be: </p><p>__int64 (__stdcall *) (int,int)</p><p></p><p>A native instance can be used in the scenarios where a method pointer with this signature is required, in fact, a native instance itself is a native pointer-to-method in Java much like a CMethod/CPPConstructor/CPPMethod/CFieldMethod mapping a DLL method, the Java method can be called from Java with the native marshalling.</p><p>An example of native call from Java:</p><p>NativeStaticMethodCallback cb = </p><p>(NativeStaticMethodCallback)new AddTwoNumbersCallback();</p><p>JNIEasy.get().getNativeManager().makeNative(cb); </p><p>long res = cb.callLong(new Object[]{new Integer(2),new Integer(3)});</p><p>System.out.println("Must be 5: " + res); </p><p>The method AddTwoNumbersCallback.add(in,int) is called using a native bridge. This feature is useful to test any Java native callback from Java.</p><p>In the native programming world is very common to use pointer-to-method parameters used as callbacks to be called into the method invoked, the C method signature is working like an &#8220;interface&#8221;, and concrete C methods can be used as parameters. In the previous example the wrapped method was static, the user defined callback class name works as the native C signature of the method, but the type and concrete method are &#8220;welded&#8221;, the user defined callback can not be used as parameter type of &#8220;implementation changeable&#8221; callback parameters of native methods declared in Java, because the callback implementation of any native callback instance is ever the same. To avoid this problem the wrapped method may be non-static, but the signature may remain as static too, a non-static method can be overwritten in an inherited class, the only limitation is the non-static method can not be abstract (neither the class).</p><p>Developing a version &#8220;to override&#8221;:</p><p>package examples.manual;</p><p></p><p>public class AddTwoNumbersCallbackToOverride</p><p>{</p><p>public AddTwoNumbersCallbackToOverride() </p><p>{</p><p>}</p><p></p><p>public long add(int a,int b)</p><p>{</p><p>throw new RuntimeException("Override this method"); </p><p>}</p><p>}</p><p>The XML enhancer file:</p><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p><p>&lt;!-- AddTwoNumbersCallbackToOverride.jnieasy.enh.xml --&gt;</p><p>&lt;jniEasyEnhancer version="1.1"&gt;</p><p>&lt;package name="examples.manual"&gt;</p><p>&lt;imports /&gt; </p><p>&lt;class name="AddTwoNumbersCallbackToOverride" type="callback" &gt;</p><p>&lt;method name="add" params="int,int" &gt;</p><p>&lt;/method&gt;</p><p>&lt;/class&gt;</p><p>&lt;/package&gt;</p><p>&lt;/jniEasyEnhancer&gt;</p><p>Note the AddTwoNumbersCallbackToOverride XML file is identical to the AddTwoNumbersCallback version, in both cases the add method is a static native method, but the native instance is used to call the add instance method.</p><p>In our example is not useful to create instances of AddTwoNumbersCallbackToOverride, because the add method does nothing (throws an exception), but the class name can be used now as a &#8220;placeholder&#8221; of concrete implementations, native Java methods now can use this class as parameter type and expect objects with derived classes. Of course another approach is to use fields to distinguish the method behavior in a per instance basis, but this approach is not so elegant.</p><p>Derived classes do not need to be enhanced, no XML enhancer descriptor is needed, and instances of these classes are native capable because the base class is already native capable.</p><p>Following the example:</p><p>package examples.manual;</p><p></p><p>public class AddTwoNumbersCallbackConcrete extends </p><p>AddTwoNumbersCallbackToOverride</p><p>{</p><p>public AddTwoNumbersCallbackConcrete() </p><p>{</p><p>}</p><p></p><p>public long add(int a,int b)</p><p>{ </p><p>return (long)a + (long)b;</p><p>} </p><p>}</p><p>Instances of this class can be made native and passed as parameters to native methods where a AddTwoNumbersCallbackToOverride object is expected.</p><p>A real world example, the EnumWindows method of the Win32 API (Microsoft documentation):</p><p>&#8220;The EnumWindows function enumerates all top-level windows on the screen by passing the handle to each window, in turn, to an application-defined callback function. EnumWindows continues until the last top-level window is enumerated or the callback function returns FALSE&#8221;<sup>[<a name="id526151" href="#ftn.id526151">11</a>]</sup>.</p><p>The C signature is the following:</p><p>BOOL EnumWindows(</p><p>WNDENUMPROC lpEnumFunc, // pointer to callback function</p><p>LPARAM lParam // application-defined value</p><p>);</p><p>where WNDENUMPROC is defined as:</p><p>typedef BOOL (CALLBACK* WNDENUMPROC)(HWND, LPARAM);</p><p>and CALLBACK is defined as: </p><p>#define CALLBACK __stdcall</p><p>The Java user defined callback &#8220;template&#8221;:</p><p>package examples.manual;</p><p></p><p>public class EnumWindowsProc</p><p>{</p><p>public EnumWindowsProc()</p><p>{</p><p>}</p><p></p><p>public int onCall(int hwnd,int lParam)</p><p>{</p><p>throw new RuntimeException("Override this method"); </p><p>}</p><p>}</p><p>The XML enhancer file:</p><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p><p>&lt;!-- EnumWindowsProc.jnieasy.enh.xml --&gt;</p><p>&lt;jniEasyEnhancer version="1.1"&gt;</p><p>&lt;package name="examples.manual"&gt;</p><p>&lt;imports /&gt; </p><p>&lt;class name="EnumWindowsProc" type="callback" &gt;</p><p>&lt;method name="onCall" callConv="std_call" </p><p>params="int,int" &gt;</p><p>&lt;/method&gt;</p><p>&lt;/class&gt;</p><p>&lt;/package&gt;</p><p>&lt;/jniEasyEnhancer&gt;</p><p>The concrete callback (no need of a XML descriptor):</p><p>package examples.manual;</p><p></p><p>public class EnumWindowsProcConcrete extends EnumWindowsProc</p><p>{</p><p>public int windowCount;</p><p></p><p>public EnumWindowsProcConcrete()</p><p>{</p><p>}</p><p></p><p>public int onCall(int hwnd, int lParam)</p><p>{</p><p>windowCount++;</p><p>return 1; // TRUE</p><p>} </p><p></p><p>public int getWindowCount()</p><p>{</p><p>return windowCount;</p><p>}</p><p>}</p><p>and finally an example of use:</p><p>DynamicLibrary dll = JNIEasy.get().getDLLManager().get("User32"); </p><p>CMethod method = dll.addCMethod("EnumWindows",int.class,</p><p>new Object[]{EnumWindowsProc.class,int.class},CallConv.STD_CALL); </p><p>EnumWindowsProc lpEnumFunc = new EnumWindowsProcConcrete();</p><p>int res = method.callInt(new Object[]{lpEnumFunc,new java.lang.Integer(5)});</p><p>System.out.println(&#8220;Opened windows :&#8221; + lpEnumFunc.getWindowCount());</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id526430"></a>Static callbacks with the method outside the class</h4></div></div></div><p>In previous examples, the exported method was inside the native capable callback class, this is not mandatory, the method can be outside the callback class and in the case of static methods the container class does not need to be a native capable class. </p><p>Example: </p><p></p><p>package examples.manual;</p><p></p><p>public class AddTwoNumbersCallbackOutside</p><p>{</p><p>public AddTwoNumbersCallbackOutside()</p><p>{</p><p>}</p><p>}</p><p>The XML enhancer descriptor:</p><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p><p>&lt;!-- AddTwoNumbersCallbackOutside.jnieasy.enh.xml --&gt;</p><p>&lt;jniEasyEnhancer version="1.1"&gt;</p><p>&lt;package name="examples.manual"&gt;</p><p>&lt;imports /&gt; </p><p>&lt;class name="AddTwoNumbersCallbackOutside" type="callback" &gt;</p><p>&lt;method name="addStatic" thisClass="MyCPPClassOnJava"</p><p>params="int,int"&gt;</p><p>&lt;/method&gt;</p><p>&lt;/class&gt;</p><p>&lt;/package&gt;</p><p>&lt;/jniEasyEnhancer&gt;</p><p>The attribute thisClass="MyCPPClassOnJava" specifies the class where the method (addStatic) must be searched. </p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id526546"></a>Instance callbacks </h4></div></div></div><p>A user defined callback can make native an instance Java method seen as instance method in the native side too. This method must be declared in a user defined native capable class declared as C++ class, structure or union (&#8220;field based&#8221; user defined native capable classes). This (native capable) method does not need to be declared as native in the container class&#8217;s XML enhancer descriptor because the native method view is managed by the callback class, anyway a native instance of the container&#8217;s class is needed to call this method from native (because is a instance/non-static method in Java and in native side). The method is invoked from native using an instance of the container class as the first parameter (using a C form layout of the instance method with a container class pointer as the first parameter). </p><p>Example: mapping the sub method of MyCPPClassOnJava</p><p>The Java callback:</p><p>package examples.manual;</p><p></p><p>public class MyCPPClassOnJavaSubCallback </p><p>{</p><p>public MyCPPClassOnJavaSubCallback()</p><p>{</p><p>}</p><p>}</p><p>The XML descriptor:</p><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p><p>&lt;!-- MyCPPClassOnJavaSubCallback.jnieasy.enh.xml --&gt;</p><p>&lt;jniEasyEnhancer version="1.1"&gt;</p><p>&lt;package name="examples.manual"&gt;</p><p>&lt;imports /&gt; </p><p>&lt;class name="MyCPPClassOnJavaSubCallback" type="callback" &gt;</p><p>&lt;method name="sub" thisClass="MyCPPClassOnJava" </p><p>params="int,int" &gt;</p><p>&lt;/method&gt;</p><p>&lt;/class&gt;</p><p>&lt;/package&gt;</p><p>&lt;/jniEasyEnhancer&gt;</p><p>The thisClass attribute specifies the container class of sub.</p><p></p><p>One step forward: declaring a constructor and destroy callbacks we have an example of a complete lifecycle of a MyCPPClassOnJava native instance without using MyCPPClassOnJava explicitly.</p><p>Mapping the two integer constructor with a Java callback:</p><p>package examples.manual;</p><p></p><p>public class MyCPPClassOnJavaConstructorCallback </p><p>{</p><p>public MyCPPClassOnJavaConstructorCallback()</p><p>{</p><p>}</p><p>}</p><p>The XML enhancer descriptor of the constructor:</p><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p><p>&lt;!-- MyCPPClassOnJavaConstructorCallback.jnieasy.enh.xml --&gt;</p><p>&lt;jniEasyEnhancer version="1.1"&gt;</p><p>&lt;package name="examples.manual"&gt;</p><p>&lt;imports /&gt; </p><p>&lt;class name="MyCPPClassOnJavaConstructorCallback" </p><p>type="callback" &gt;</p><p>&lt;constructor thisClass="MyCPPClassOnJava"</p><p>params="int,int"&gt;</p><p>&lt;/constructor&gt;</p><p>&lt;/class&gt;</p><p>&lt;/package&gt;</p><p>&lt;/jniEasyEnhancer&gt;</p><p>Mapping the destroy method with a Java callback:</p><p></p><p>package examples.manual;</p><p></p><p>public class MyCPPClassOnJavaDestroyCallback </p><p>{</p><p>public MyCPPClassOnJavaDestroyCallback()</p><p>{</p><p>} </p><p>}</p><p>The XML enhancer descriptor of the destroy callback:</p><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p><p>&lt;!-- MyCPPClassOnJavaDestroyCallback.jnieasy.enh.xml --&gt;</p><p>&lt;jniEasyEnhancer version="1.1"&gt;</p><p>&lt;package name="examples.manual"&gt;</p><p>&lt;imports /&gt; </p><p>&lt;class name="MyCPPClassOnJavaDestroyCallback" type="callback" &gt;</p><p>&lt;method name="destroy" thisClass="MyCPPClassOnJava" </p><p>params="MyCPPClassOnJava"&gt;</p><p>&lt;/method&gt;</p><p>&lt;/class&gt;</p><p>&lt;/package&gt;</p><p>&lt;/jniEasyEnhancer&gt;</p><p>Putting it all together:</p><p>NativeConstructorCallback constCb = </p><p>(NativeConstructorCallback)new MyCPPClassOnJavaConstructorCallback();</p><p>JNIEasy.get().getNativeManager().makeNative(constCb); </p><p>Object[] args = new Object[] { new Integer(2), new Integer(3) };</p><p>Object obj = constCb.call(args); // Calls constructor and</p><p>// returns a native MyCPPClassOnJava instance</p><p>NativeInstanceMethodCallback cb = </p><p>(NativeInstanceMethodCallback)new MyCPPClassOnJavaSubCallback();</p><p>JNIEasy.get().getNativeManager().makeNative(cb); </p><p>args = new Object[] { new Integer(2), new Integer(3) };</p><p>double res = cb.callDouble(obj,args); // Calls sub(int,int)</p><p></p><p>NativeStaticMethodCallback destCb = </p><p>(NativeStaticMethodCallback)new MyCPPClassOnJavaDestroyCallback();</p><p>JNIEasy.get().getNativeManager().makeNative(destCb); </p><p>destCb.callVoid(new Object[]{obj}); // Calls destroy(MyCPPClassOnJava)</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id526959"></a>Exporting the callbacks to the native side</h4></div></div></div><p>The exportMethod="true" can be used in the declaration of a user defined native capable callback, if set, a native instance callback is created, made native and exported when the callback class is loaded.</p><p>Example: updating the AddTwoNumbersCallback XML file:</p><p>...</p><p>&lt;class name="AddTwoNumbersCallback" type="callback" &gt;</p><p>&lt;method name="add" exportMethod="true" &gt; </p><p>...</p><p>In the native side the callback pointer can be obtained using findExportedMethodAddress and the signature name:</p><p>"examples.manual.AddTwoNumbersCallback.add(int,int)"</p><p>Example:</p><p>JNIEasyLibrary dll = JNIEasy.get().getJNIEasyLib();</p><p>String sig = "examples.manual.AddTwoNumbersCallback.add(int,int)";</p><p>NativeStaticMethod method = </p><p>(NativeStaticMethod)dll.findExportedMethodAddress(sig);</p><p>long res = method.callLong(new Object[]{new Integer(1),new Integer(2)}); </p><p>// add(1,2) call</p><p>System.out.println("Must be 3: " + res);</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id527040"></a>User defined pointers</h3></div></div></div><p>The NativePointer interface is implemented by native capable classes wrapping a native capable or &#8220;can be native&#8221; object reference working as a native pointer. A NativePointer native instance holds a native pointer, wherefore a NativePointer native reference is like a C/C++ &#8220;pointer to pointer&#8221; (ex. int**).</p><p>The framework offers a default implementation, therefore a NativePointer field can be declared as a native field in a structure etc; the internal pointer (which type is declared in the XML descriptor of the field) can be got /set with the methods getValue()/setValue(Object).</p><p>The developer can code user defined native capable class pointers holding a field with a fixed pointer type. These user defined classes can be used instead of the default implementation.</p><p>Example: a pointer to an UNICODE String (wchar_t**) </p><p>package examples.manual;</p><p></p><p>public class PointerToString</p><p>{ </p><p>protected String ptrToStr;</p><p></p><p>public PointerToString() // mandatory</p><p>{</p><p>}</p><p></p><p>public PointerToString(String pointer)</p><p>{</p><p>this.ptrToStr = pointer;</p><p>} </p><p></p><p>public String getString()</p><p>{</p><p>return ptrToStr;</p><p>}</p><p></p><p>public void setString(String pointer)</p><p>{</p><p>this.ptrToStr = pointer;</p><p>} </p><p>}</p><p>The XML enhancer file:</p><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p><p>&lt;!-- Archive PointerToString.jnieasy.enh.xml --&gt;</p><p>&lt;jniEasyEnhancer version="1.1"&gt;</p><p>&lt;package name="examples.manual"&gt;</p><p>&lt;imports/&gt; </p><p>&lt;class name="PointerToString" type="pointer"&gt;</p><p>&lt;field name="ptrToStr" encoding="unicode" /&gt;</p><p>&lt;/class&gt;</p><p>&lt;/package&gt; </p><p>&lt;/jniEasyEnhancer&gt;</p><p>A PointerToString reference is seen as a char** C type.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id527225"></a>User defined native capable arrays</h3></div></div></div><p>Java arrays need native capable classes to manage its native state. All combinations of Java arrays of enabled types are managed by the framework, including multidimensional arrays. Most of them have a specific interface/default native capable class with no need of casting. </p><p>There are two families of arrays with a default implementation managing multiple types (casting needed):</p><div class="orderedlist"><ol type="1"><li><p>Multidimensional arrays (ex. int[][])</p></li><li><p>Arrays of native capable classes (ex. MyStructure[] or NativeString[])</p></li></ol></div><p>The developer can code user defined native capable class arrays holding a concrete Java array field: a native capable or multidimensional array. These user defined classes can be used instead of the default implementation.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id527276"></a>Multidimensional arrays</h4></div></div></div><p>Example: a two-dimensional int array</p><p>package examples.manual;</p><p></p><p>import com.innowhere.jnieasy.core.data.NativeObjectArray;</p><p></p><p>public class IntArray2Dim </p><p>{</p><p>private int[][] value; </p><p></p><p>public IntArray2Dim() // mandatory</p><p>{</p><p>}</p><p></p><p>public IntArray2Dim(int[][] value)</p><p>{</p><p>this.value = value;</p><p>}</p><p></p><p>public int[][] getIntArray()</p><p>{</p><p>return value; </p><p>}</p><p></p><p>public void setIntArray(int[][] value)</p><p>{</p><p>this.value = value; </p><p>}</p><p></p><p>public int getInt(int[] dims)</p><p>{</p><p>return this.value[dims[0]][dims[1]];</p><p>} </p><p></p><p>public void setInt(int[] dims,int newValue)</p><p>{</p><p>int[][] aux = this.value;</p><p>aux[dims[0]][dims[1]] = newValue;</p><p>this.value = aux;</p><p>} </p><p></p><p>public int getIntQuick(int[] dims)</p><p>{</p><p>NativeObjectArray thisArr = (NativeObjectArray)this;</p><p>return ((Integer)thisArr.getElement(dims)).intValue();</p><p>}</p><p></p><p>public void setIntQuick(int[] dims,int newValue)</p><p>{</p><p>NativeObjectArray thisArr = (NativeObjectArray)this;</p><p>thisArr.setElement(dims,new Integer(newValue));</p><p>} </p><p>}</p><p></p><p>The XML enhancer file:</p><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p><p>&lt;!-- Archive IntArray2Dim.jnieasy.enh.xml --&gt;</p><p>&lt;jniEasyEnhancer version="1.1"&gt;</p><p>&lt;package name="examples.manual"&gt;</p><p>&lt;imports/&gt; </p><p>&lt;class name="IntArray2Dim" type="array"&gt;</p><p>&lt;field name="value" /&gt; </p><p>&lt;/class&gt;</p><p>&lt;/package&gt; </p><p>&lt;/jniEasyEnhancer&gt;</p><p>The field value is internally and automatically declared &#8220;by value&#8221; (the native memory layout is the same as a structure with a single array field by value), and can not be declared &#8220;by pointer&#8221;.</p><p>The native capable array container can have any values of dimensions; a concrete instance and field value imposes the max values of dimensions (and memory size). To declare fixed values (lengths) of dimensions:</p><p>. . .</p><p>&lt;field name="value" length="2"&gt;</p><p>&lt;component length="3" /&gt;</p><p>&lt;/field&gt;</p><p>. . .</p><p>The previous example declares the custom class as a fixed size array, all instances have the same maximum lengths (2 and 3).</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id527571"></a>Review of the method getInt(int[])</h5></div></div></div>Review of the method getInt(int[])<p>The methods getInt(int[]) and setInt(int[],int) are examples of methods to get and set an element of the array ensuring synchronization with the native memory, the enhancer can not control an element access of an array. </p><p>return this.value[dims[0]][dims[1]];</p><p>Reads the native memory and copies the array in this.value, then returns the concrete element read from Java memory.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id527594"></a>Review of the method setInt(int[],int)</h5></div></div></div>Review of the method setInt(int[],int)<p>int[][] aux = this.value; </p><p>The aux = this.value; reads the native memory and copies the array in this.value, the array reference points to the Java array.</p><p>aux[dims[0]][dims[1]] = newValue;</p><p>Sets the new element in the array on Java memory.</p><p>this.value = aux;</p><p>Updates the this.value field and the native memory of the whole array.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id527628"></a>Review of the &#8220;quick&#8221; methods</h5></div></div></div><p>The methods getIntQuick(int[]) and setIntQuick(int[],int) are the speeder versions of the previous methods, only the strictly necessary native memory is read/written (the element read/updated). The multidimensional array is a NativeObjectArray after the enhancement process. Of course NativeObjectArray methods can be called outside the class.</p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id527636"></a>Arrays of native capable classes</h4></div></div></div><p>Example: an array of structures (elements declared &#8220;by pointer&#8221;).</p><p>package examples.manual;</p><p></p><p>import com.innowhere.jnieasy.core.data.NativeObjectArray;</p><p></p><p>public class MyStructureArray</p><p>{</p><p>private MyStructure[] value;</p><p></p><p>public MyStructureArray()</p><p>{</p><p>}</p><p></p><p>public MyStructureArray(MyStructure[] value)</p><p>{</p><p>this.value = value;</p><p>}</p><p></p><p>public MyStructure[] getStructArray()</p><p>{</p><p>return value; </p><p>}</p><p></p><p>public void setStructArray(MyStructure[] value)</p><p>{</p><p>this.value = value; </p><p>}</p><p></p><p>public MyStructure getStruct(int index)</p><p>{</p><p>return value[index]; </p><p>}</p><p></p><p>public void setStruct(int index,MyStructure value)</p><p>{</p><p>MyStructure[] aux = this.value;</p><p>aux[index] = value;</p><p>this.value = aux;</p><p>} </p><p></p><p>public MyStructure getStructQuick(int index)</p><p>{</p><p>NativeObjectArray thisArr = (NativeObjectArray)this;</p><p>return (MyStructure)thisArr.getElement(index);</p><p>}</p><p></p><p>public void setStructQuick(int index,MyStructure value)</p><p>{</p><p>NativeObjectArray thisArr = (NativeObjectArray)this;</p><p>thisArr.setElement(index,value);</p><p>} </p><p>}</p><p>The XML enhancer file:</p><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p><p>&lt;!-- Archive MyStructureArray.jnieasy.enh.xml --&gt;</p><p>&lt;jniEasyEnhancer version="1.1"&gt;</p><p>&lt;package name="examples.manual"&gt;</p><p>&lt;imports/&gt; </p><p>&lt;class name="MyStructureArray" type="array"&gt;</p><p>&lt;field name="value" /&gt;</p><p>&lt;/class&gt;</p><p>&lt;/package&gt; </p><p>&lt;/jniEasyEnhancer&gt;</p><p>Again the field value is internally declared &#8220;by value&#8221;, the native capable array container can have any values of dimensions (a fixed array length can be specified too with the length attribute); array elements (structures) are declared &#8220;by pointer&#8221; (the default native variable type), then MyStructureArray is an array of MyStructure pointers (MyStructure*[]).</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id527903"></a>mapping native legacy classes</h3></div></div></div><p>We have seen how a C++ class can be accessed from Java using JNIEasy, basically exporting the required methods and adding standard or C call conventions. What about a legacy C++ class? If we cannot touch the source code we can ever add special C methods wrapping and exporting legacy methods. In C++ an instance method is called passing as first parameter a pointer to the object instance, an instance method is basically a C method with a hidden parameter (a pointer to the object), a virtual table is used to resolve the address of the method. We can simulate with C methods false C++ methods, of course excluding virtual addressing. </p><p>Example: </p><p>Legacy C++ class MyLegacyClassOnDLL (header):</p><p>#ifndef MyLegacyClassOnDLL_h</p><p>#define MyLegacyClassOnDLL_h</p><p></p><p>#include "JNIEasy.h"</p><p></p><p>// MyLegacyClassOnDLL.h</p><p>class MyLegacyClassOnDLL</p><p>{</p><p>protected:</p><p>double m_value;</p><p></p><p>public:</p><p>MyLegacyClassOnDLL(int a,int b);</p><p>virtual ~MyLegacyClassOnDLL();</p><p></p><p>static __int64 addStatic(int a,int b);</p><p></p><p>double getValue();</p><p></p><p>virtual double sub(int a,int b);</p><p>};</p><p></p><p>extern "C"</p><p>{</p><p>DLLEXPORT MyLegacyClassOnDLL* __stdcall MyLegacyClassOnDLL_create(</p><p>int a,int b);</p><p>DLLEXPORT void __stdcall MyLegacyClassOnDLL_destroy(</p><p>MyLegacyClassOnDLL* obj);</p><p>DLLEXPORT __int64 __stdcall MyLegacyClassOnDLL_addStatic(int a,int b);</p><p>DLLEXPORT double __stdcall MyLegacyClassOnDLL_getValue(</p><p>MyLegacyClassOnDLL* obj);</p><p>DLLEXPORT double __stdcall MyLegacyClassOnDLL_sub(</p><p>MyLegacyClassOnDLL* obj,int a,int b);</p><p>}</p><p></p><p>#endif</p><p>Implementation:</p><p>#include "MyLegacyClassOnDLL.h"</p><p>#include &lt;stdio.h&gt;</p><p>#include &lt;stdarg.h&gt;</p><p></p><p>MyLegacyClassOnDLL::MyLegacyClassOnDLL(int a,int b)</p><p>{</p><p>m_value = a + b;</p><p>}</p><p></p><p>MyLegacyClassOnDLL::~MyLegacyClassOnDLL()</p><p>{</p><p>}</p><p></p><p>__int64 MyLegacyClassOnDLL::addStatic(int a,int b)</p><p>{</p><p>return (__int64)a + (__int64)b;</p><p>}</p><p></p><p>double MyLegacyClassOnDLL::getValue()</p><p>{</p><p>return m_value;</p><p>}</p><p></p><p>double MyLegacyClassOnDLL::sub(int a,int b)</p><p>{</p><p>m_value = m_value - (a + b);</p><p>return m_value;</p><p>}</p><p></p><p>// Wrapper Methods </p><p></p><p>MyLegacyClassOnDLL* __stdcall MyLegacyClassOnDLL_create(int a,int b)</p><p>{</p><p>return new MyLegacyClassOnDLL(a , b); // may be an inherited class</p><p>}</p><p></p><p>void __stdcall MyLegacyClassOnDLL_destroy(MyLegacyClassOnDLL* obj)</p><p>{</p><p>delete obj;</p><p>}</p><p></p><p>__int64 __stdcall MyLegacyClassOnDLL_addStatic(int a,int b)</p><p>{</p><p>return MyLegacyClassOnDLL::addStatic(a,b);</p><p>}</p><p></p><p>double __stdcall MyLegacyClassOnDLL_getValue(MyLegacyClassOnDLL* obj)</p><p>{</p><p>return obj-&gt;getValue();</p><p>}</p><p></p><p>double __stdcall MyLegacyClassOnDLL_sub(MyLegacyClassOnDLL* obj,</p><p>int a,int b)</p><p>{</p><p>return obj-&gt;sub(a,b);</p><p>}</p><p></p><p>C methods are simple wrappers of the C++ methods exporting them to Java. Original class fields can be directly mapped in Java.</p><p>The Java class:</p><p>public class MyLegacyClassOnDLL</p><p>{</p><p>protected int virtualTable; // the C++ class has a virtual method</p><p>protected double value;</p><p></p><p>public MyLegacyClassOnDLL() // mandatory (is not native) </p><p>{</p><p>}</p><p></p><p>public MyLegacyClassOnDLL(int a, int b)</p><p>{</p><p>throw new RuntimeException("Not enhanced"); </p><p>} </p><p></p><p>public static native void destroy(MyLegacyClassOnDLL obj);</p><p></p><p>public static native long addStatic(int a,int b);</p><p></p><p>public double getValue()</p><p>{</p><p>return value;</p><p>}</p><p></p><p>public native double sub(int a,int b);</p><p>}</p><p></p><p>The XML file, MyLegacyClassOnDLL.jnieasy.enh.xml, for the enhancer (is added to the enhancer XML descriptor with the list to enhance too):</p><p>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</p><p>&lt;!-- Archive MyLegacyClassOnDLL.jnieasy.enh.xml --&gt;</p><p>&lt;jniEasyEnhancer version="1.1" ...&gt; </p><p></p><p>&lt;package name="examples.manual"&gt;</p><p>&lt;imports/&gt; </p><p>&lt;class name="MyLegacyClassOnDLL" type="class" </p><p>libraryPath="MyLibrary" &gt;</p><p></p><p>&lt;constructor onLibrary="true"</p><p>nativeName="MSC:_MyLegacyClassOnDLL_create@8;gcc:MyLegacyClassOnDLL_create" params="int, int"&gt; </p><p>&lt;/constructor&gt; </p><p></p><p>&lt;method name="destroy" onLibrary="true" </p><p>nativeName="MSC:_MyLegacyClassOnDLL_destroy@4;gcc:MyLegacyClassOnDLL_destroy" params="MyLegacyClassOnDLL"&gt; </p><p>&lt;/method&gt; </p><p></p><p>&lt;method name="addStatic" onLibrary="true" </p><p>nativeName="MSC:_MyLegacyClassOnDLL_addStatic@8;gcc:MyLegacyClassOnDLL_addStatic" params="int,int"&gt;</p><p>&lt;/method&gt;</p><p></p><p>&lt;method name="sub" onLibrary="true" </p><p>nativeName="MSC:_MyLegacyClassOnDLL_sub@12;gcc:MyLegacyClassOnDLL_sub"</p><p>params="int,int"&gt;</p><p>&lt;/method&gt; </p><p></p><p>&lt;/class&gt; </p><p>&lt;/package&gt; </p><p>&lt;/jniEasyEnhancer&gt;</p><p></p><p>And finally a use example:</p><p>byte res = MyLegacyClassOnDLL.addStatic(1,2);</p><p>System.out.println("Must be 3: " + res);</p><p></p><p>MyLegacyClassOnDLL obj = new MyLegacyClassOnDLL(1,2); </p><p>// Calls create() C++ method. New object is already native</p><p>System.out.println("Must be 3: " + obj.getValue());</p><p>// Java method getValue() is not native (field &#8220;value&#8221; is native) </p><p></p><p>double res2 = obj.sub(1,2);</p><p>System.out.println("Must be 0: " + res2);</p><p></p><p>MyLegacyClassOnDLL.destroy(obj); </p><p>// Calls the C++ method destroy(), the memory is freed</p><p></p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id522559" href="#id522559">3</a>] </sup>This is the default native layout of Java primitives (and derivatives), but this correspondence can be changed, for instance: the Java char (2 bytes) can be reflected as a C char (1 byte), the Java long (8 bytes) can be reflected as a 32 bit C int etc. See Cross-platform options.</p></div><div class="footnote"><p><sup>[<a name="ftn.id522702" href="#id522702">4</a>] </sup>Microsoft (Visual) C/C++ compiler</p></div><div class="footnote"><p><sup>[<a name="ftn.id523227" href="#id523227">5</a>] </sup>All C++ examples of this manual and included into the JNIEasy distribution compile with MSVC 6.0 and a modern gcc (MingGW, cygwin, Linux, Mac and Solaris) compiler, nothing prevent to compile with other compilers like Borland C/C++, Intel C/C++ or Sun Studio, perhaps with minor modifications of JNIEasy.h (furthermore, native libraries are language independent, you need to know how native data types are corresponded with Java/JNI data types). The static linking with JNIEasy is only supported with MSVC but can be avoided using JNIEasy.c or JNIEasyHelper.cpp provided files, static or dynamic linking to JNIEasy DLL is not necessary if findExportedMethodAddress(const char*) method is not used from native.</p></div><div class="footnote"><p><sup>[<a name="ftn.id523534" href="#id523534">6</a>] </sup>In a x86 unix gcc compiler the MyCPPClassOnDLL C++ class must be compiled with the flag -malign-double because by default the alignment of double declared as a field is 4 bytes, this value is the recommended default in old i386 machines, but this alignment is an anachronism and is different to the double type size, 8 bytes (primitive sizes and alignments usually share the same value), and incompatible with modern Win32 compilers (MSVC and Win32 gcc ports always align double with 8 bytes).</p><p></p></div><div class="footnote"><p><sup>[<a name="ftn.id523976" href="#id523976">7</a>] </sup>The used native names in this manual follow the C++ name mangling of MSVC compiler; in the Cross-platform options chapter we will see how to define a cross-platform native name valid with gcc too. The examples contained into the distribution are fully cross-platform.</p></div><div class="footnote"><p><sup>[<a name="ftn.id523992" href="#id523992">8</a>] </sup>
<a href="http://www.wheaty.net/downloads.htm" target="_top">http://www.wheaty.net/downloads.htm</a> </p></div><div class="footnote"><p><sup>[<a name="ftn.id524013" href="#id524013">9</a>] </sup>
<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/debug/base/undecoratesymbolname.asp" target="_top">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/debug/base/undecoratesymbolname.asp</a> </p></div><div class="footnote"><p><sup>[<a name="ftn.id524807" href="#id524807">10</a>] </sup>The Class object existence indicates the class is loaded but it may be not initialized </p></div><div class="footnote"><p><sup>[<a name="ftn.id526151" href="#id526151">11</a>] </sup>http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/windowsuserinterface/windowing/windows/windowreference/windowfunctions/enumwindows.asp</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s06.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s08.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Runtime Life Cycle </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Enhancer</td></tr></table></div></body></html>
