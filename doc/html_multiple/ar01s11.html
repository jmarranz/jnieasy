<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Cross-platform options</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title=""><link rel="up" href="index.html" title=""><link rel="prev" href="ar01s10.html" title="Direct memory manipulation"><link rel="next" href="ar01s12.html" title="Native Transactions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Cross-platform options</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s10.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s12.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id529833"></a>Cross-platform options</h2></div></div></div><p>Main objective of JNIEasy&#8217;s cross-platform options is simple: one Java code, multiple operating systems, compilers and native layouts<sup>[<a name="id529845" href="#ftn.id529845">12</a>]</sup>. The cross-platform in this context means cross-operating system, cross-compiler and cross-native layouts. </p><p>To achieve this objective JNIEasy offers several features:</p><div class="orderedlist"><ol type="1"><li><p>Platform dependent size of addresses</p></li><li><p>Multiple native memory sizes and alignments of primitive types</p></li><li><p>A C &#8220;inspired&#8221; macro based system to resolve sizes and names</p></li></ol></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id529898"></a>platform dependent size of addresses</h3></div></div></div><p>Java primitive data types have fixed sizes; it was a very successful rule, because a pure Java program works exactly equal in all platforms. But this is a problem making Java and C/C++ integration, because all pointer types like void* and long data type<sup>[<a name="id529910" href="#ftn.id529910">13</a>]</sup> are platform dependent: in a 32 bit platform pointers and long size is 4 bytes (same as int), in a 64 bit environment pointers have 8 bytes and long has 8 bytes too in a LP64 model<sup>[<a name="id529921" href="#ftn.id529921">14</a>]</sup> (fortunately int maintains the same size, 32 bits). In a 32 bit platform the C/C++ long/int/anytype* &#8211; Java int correspondence does not work fully in a 64 bit platform; the portable correlation must be C/C++ jint and Java int or C/C++ jlong and Java long, but is very unusual to see C/C++ legacy code using JNI data types. </p><p>One solution is to offer 32 bit and 64 bit versions of Java programs based in JNIEasy, the 32 bit version will use the Java int and the 64 bit version the long data type will be used to map the C/C++ long, in a LP64 platform, or to map an address/handler (usually handlers are pointers to undocumented structures).</p><p>The other solution is to use cross-platform addresses. </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id529975"></a>Built-in facilities</h4></div></div></div><p>JNIEasy is ready to the 64 bit platforms (x86 AMD64/EM64T architectures). </p><p>JNIEasy uses the long type to deal with native addresses, memory sizes and offsets, in a 32 bit platform the addresses (and related memory sizes) are promoted to long normally (the four upper bytes are ever 0 if the integer value is positive or FFFFFFFF if negative) and cast to 32 bits with a normal cast operation (the signed value is ever unaltered). In a 64 bit platform no cast will be made.</p><p>References (pointers) have a platform dependent variable size automatically: a Java native reference in a Java user defined native capable structure, or C++ class etc (e.g. a field with a native capable data type or &#8220;can be native&#8221; reference) occupies 32 bits in a 32 bit platform and 64 bits in a 64 bit platform.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id530009"></a>Cross-platform long</h4></div></div></div>Cross-platform long<p>Another facility is to use the Java long data type as a cross-platform data type in a native perspective.</p><p>A cross-platform Java long occupies in the native memory 32 bits in a 32 bit platform and 64 bits in a 64 bit platform. A cross-platform long works as the C/C++ long and pointers types, using the cross-platform long the 64 bits and 32 bits Java versions are the same, only one API.</p><p>To declare a cross-platform long must be used the XML attribute &#8220;address&#8221;, if set to &#8220;true&#8221; the long native size is platform dependent (the size of addresses of the platform). Arrays, Long, NativeLong and NativeLongObject data types can contain a long cross-platform, declaring the long component as address with the optional &lt;component&gt; child element (see Primitive wrapper types and Primitive object types). </p><p>To declare a cross-platform long using a programmatic manner use the NativeTypeManager.decAddress() method.</p><p>Examples:</p><p>public class MyStructure</p><p>{</p><p>. . . </p><p>protected long crossPlatLong;</p><p>protected long[] crossPlatLongArray = new long[]{1,2};</p><p>protected Long crossPlatLongObject = new Long();</p><p>protected NativeLong crossPlatNativeLong;</p><p>protected NativeLongObject crossPlatNativeLongObject; </p><p></p><p>public MyStructure()</p><p>{ </p><p> . . . </p><p>NativeTypeManager typeMgr = JNIEasy.get().getTypeManager();</p><p>this.crossPlatNativeLong = (NativeLong)typeMgr.decAddress().</p><p>decObjectWrapper(NativeLong.class).newValue();</p><p>this.crossPlatNativeLongObject = (NativeLongObject)typeMgr.decAddress().</p><p>decObjectWrapper(NativeLongObject.class).newValue();</p><p>}</p><p>...</p><p>}</p><p></p><p>XML enhancer descriptor:</p><p>. . .</p><p>&lt;field name="crossPlatLong" address="true" /&gt;</p><p>&lt;field name="crossPlatLongArray" &gt; </p><p>&lt;component address="true" /&gt;</p><p>&lt;/field&gt;</p><p>&lt;field name="crossPlatLongObject" &gt; </p><p>&lt;component address="true" /&gt;</p><p>&lt;/field&gt;</p><p>&lt;field name="crossPlatNativeLong" &gt; </p><p>&lt;component address="true" /&gt;</p><p>&lt;/field&gt;</p><p>&lt;field name="crossPlatNativeLongObject" &gt; </p><p>&lt;component address="true" /&gt;</p><p>&lt;/field&gt;</p><p>. . .</p><p>In a 32 bit platform the size of the crossPlatLong attribute is 32 bits, the crossPlatLongArray reference points to an array containing 32 bit integers and crossPlatLongObject, crossPlatNativeLong and crossPlatNativeLongObject references point to 32 bit integers.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id530218"></a>Multiple native memory sizes and alignments of primitive types</h3></div></div></div><p>Java primitive types (boolean, byte, char, short, int, long, float, double) have a default native type, the native type can be seen as the JNI type (jboolean, jbyte, jchar, jshort, jint, jlong, jfloat, jdouble). Java ensures fixed memory sizes to the primitive types in the Java side, by default native counterparts in JNIEasy have the same sizes (and alignments), but this can be changed on user demand.</p><p>Custom sizes help the developer to program in Java with more fidelity to the native side. Example: the native counterpart to the Java char is not the C char, it is short or wchar_t (with 2 bytes) and vice versa, the C char counterpart is the Java byte. The Java byte conventions are not the same as the Java char, if contained data is a character the byte data type is not the best match. Another example is Java boolean (1 byte) and BOOLEAN Win32&#8217;s macro (both types conceptually match but the size does not).</p><p>JNIEasy lets to change the default size and alignment of the native primitive type layout of a Java primitive data type globally or with a per-element basis (usually primitive fields or method parameters).</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id530255"></a>Changing the global default size and alignment </h4></div></div></div>Changing the global default size and alignment <p>The methods NativeTypeManager.setDefaultXSize(long size, long alignment), where X is Boolean, Char, Int etc, can be used to define the default size and alignment of primitive types globally. To set the desired default values before any native memory access is highly recommended. Usually the alignment is the same as the memory size, the methods NativeTypeManager.setDefaultXSize(long size) set the alignment to the memory size passed as argument.</p><p>Example:</p><p>JNIEasy. get().getTypeManager().setDefaultCharSize(1,1); </p><p>sets the default size and alignment of Java char in native as 1 (like the C char).</p><p>To know the valid values see the javadoc documentation of setDefaultXSize(long,long) methods.</p><p>NativeBuffer and NativeBufferIterator methods are not affected by the primitive default sizes, the native sizes are ever the Java sizes.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id530304"></a>Changing the default size and alignment of a native element</h4></div></div></div><p>Any primitive type element can be declared with a custom native memory size and/or alignment with the XML attributes memSize and prefAlignSize. </p><p>Example:</p><p>public class MyStructure</p><p>{</p><p>... </p><p>protected char cChar;</p><p>...</p><p>}</p><p>and XML enhancer descriptor:</p><p>. . .</p><p>&lt;field name="cChar" memSize="1" /&gt;</p><p>. . .</p><p>Previous XML code declares cChar with native memory size 1 byte and alignment 1 byte (if memory size is specified and alignment is not, the alignment is set to the memory size).</p><p>&#8220;Verification&#8221; with Java:</p><p>NativeTypeManager typeMgr = JNIEasy.get().getTypeManager();</p><p>StructureDescriptor strucDesc = </p><p>(StructureDescriptor)typeMgr.getClassDescriptor(MyStructure.class);</p><p>NativeFieldDescriptor fieldDesc = strucDesc.getField("cChar");</p><p>TypeNative fieldType = fieldDesc.getVarType().getType();</p><p>System.out.println("Must be 1: " + fieldType.size());</p><p>System.out.println("Must be 1: " + fieldType.preferredAlignSize()); </p><p>Using a programmatic approach the method NativeTypeManager.decPrimitive(Class clasz,long size, long alignment) declares a primitive native type with the memory size and alignment specified (using the method NativeTypeManager.decPrimitive(Class clasz,long size) the alignment is set as the specified size). </p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id530407"></a>Phantom primitive fields</h5></div></div></div>Phantom primitive fields<p>Size 0 is a valid native memory size and alignment of primitive types. A primitive field with native memory size 0 is a phantom field; a phantom field has no native memory layout influence (alignment must be set to 0 too). They are interesting when a specific platform declares a field not declared in another platform using C macros. This feature is only useful used in conjunction with the JNIEasy&#8217;s macro system.</p></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id530430"></a>C &#8220;inspired&#8221; macro system to resolve sizes and names</h3></div></div></div><p>The C macro system is &#8220;a blessing&#8221; in the C/C++ world because it enables the developer to face the incompatibilities of platforms, compilers, library versions &#8230; </p><p>Java has not a C macro like system because the ClassLoader mechanism and the WORA principle (the JVM works the same on every platform) are the alternatives. But in JNIEasy these features are not sufficient because JNIEasy needs to deal with native elements, a native element can be different between platforms. To face this problem JNIEasy introduces an C &#8220;inspired&#8221; macro system: a name or size can vary between platforms, the used name or size is resolved on runtime depending on declared macros, defined or not, in runtime.</p><p>Main identified cases:</p><div class="orderedlist"><ol type="1"><li><p>DLL names: a dynamic library name can change between platforms. Example: MSVCRT.DLL (lib name, MSVCRT) is the C runtime library on Windows, libc.so.6 on Linux, libc.so.1 on Solaris and libc.dylib on Mac OS X. </p></li><li><p>Exported symbols/names of methods and fields: the name mangling is different between compilers, it affects to C++ exported elements and standard call C methods (MSVC add a @N suffix).</p></li><li><p>Size (and alignment) of primitive data types: primitive data types (and derivatives) can have different size between platforms (and compilers), for instance the long data type is 4 bytes in gcc Linux/Mac/Solaris x86 and 8 bytes in x86_64, the LONG_PTR has variable size too in Windows-MSVC. </p></li></ol></div><p>JNIEasy provides a macro name/value registry with methods like NativeTypeManager.defineMacro(String,Object), NativeTypeManager.getMacro(String) etc. These macros are used to resolve expressions where the selected value is obtained if a concrete macro was declared. The approach is similar to the #ifdef MACRO or #if defined(MACRO) C/C++ preprocessor instructions.</p><p>Three methods can be used to parse macro based expressions:</p><div class="orderedlist"><ol type="1"><li><p>NativeTypeManager.parseTextWithMacros(String textExpr)</p></li></ol></div><p>Returns the text prefixed with a previously defined macro (see the javadoc for a full syntax description). </p><p>Example: </p><p>"WIN32:MSVCRT;Linux:/lib/libc.so.6;Mac:/usr/lib/libc.dylib;SunOS:/lib/libc.so.1;OtherLibc"</p><p>The name "MSVCRT" is returned if the "WIN32" macro was defined, else "/lib/libc.so.6" if the "Linux" macro was defined, else &#8220;/usr/lib/libc.dylib" if the "Mac" macro was defined else "/lib/libc.so.1" if the "SunOS" macro was defined else "OtherLibc".</p><div class="orderedlist"><ol type="1"><li><p>NativeTypeManager.parseNameWithMacros(String nameExpr)</p></li></ol></div><p>Is used to resolve names prefixed with macros, is based on parseTextWithMacros (basically trims the leading and trailing spaces).</p><div class="orderedlist"><ol type="1"><li><p>NativeTypeManager.parseMemorySizeWithMacros(String sizeExpr)</p></li></ol></div><p>Returns the size prefixed with a previously defined macro (see the javadoc for a full syntax description). </p><p>Example: "MSC:4;gcc:8;REGISTER_SIZE" the size returned is 4 if the "MSC" macro was defined, else is 8 if the "gcc" macro was defined, else the value of the "REGISTER_SIZE" macro is used (must be defined with an integer value or an exception is thrown).</p><p>Several JNIEasy methods already support directly this macro based syntax like DLLManager.get(String)/find(String)/remove(String), DynamicLibrary.getAddress(String)/addDLLBehavior(String,&#8230;)/ findBehaviorsByName(String)/findBehaviorByName(String,&#8230;)/ removeBehaviorsByName(String)/removeBehaviorByName(String,&#8230;), JNIEasyLibrary.exportBehavior(String,&#8230;), NativeTypeManager.decPrimitive(Class,String,String)/ decPrimitive(Class,String) / decString(Class,String)/ decStringBuffer(Class,String).</p><p>XML attributes (enhancer and code generation) support this syntax too:</p><div class="orderedlist"><ol type="1"><li><p>libraryPath : parsed with NativeTypeManager.parseNameWithMacros(String)</p></li><li><p>nativeName : parsed with NativeTypeManager.parseNameWithMacros(String)</p></li><li><p>encoding : parsed with NativeTypeManager.parseNameWithMacros(String)</p></li><li><p>memSize : parsed with NativeTypeManager.parseMemorySizeWithMacros(String)</p></li><li><p>prefAlignSize : parsed with NativeTypeManager.parseMemorySizeWithMacros(String)</p></li><li><p>alignSize : parsed with NativeTypeManager.parseMemorySizeWithMacros(String)</p></li></ol></div><p>Example:</p><p>NativeTypeManager typeMgr = JNIEasy.get().getTypeManager(); </p><p>String osname = System.getProperty("os.name"); </p><p>if (osname.startsWith("Windows"))</p><p>typeMgr.defineMacro("Windows");</p><p>else if (osname.startsWith("Linux"))</p><p>typeMgr.defineMacro("Linux");</p><p>else if (osname.startsWith("Mac OS X"))</p><p>typeMgr.defineMacro("MacOSX");</p><p>else if (osname.startsWith("SunOS"))</p><p>typeMgr.defineMacro("SunOS");</p><p></p><p>String dllName = "Windows:MSVCRT;Linux:/lib/libc.so.6;MacOSX:/usr/lib/libc.dylib;SunOS:/lib/libc.so.1";</p><p>DLLManager dllMgr = JNIEasy.get().getDLLManager();</p><p>DynamicLibrary dll = dllMgr.get(dllName);</p><p>CMethod method = dll.addCMethod("abs",int.class,</p><p>new Object[]{int.class},CallConv.C_CALL);</p><p>int res = method.callInt(new Object[]{ new Integer(-10) });</p><p>System.out.println("Must be true: " + (res == 10));</p><p></p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id529845" href="#id529845">12</a>] </sup>C/C++ typically use macros to construct multiple native layouts of the same construction (class, structure &#8230;)</p></div><div class="footnote"><p><sup>[<a name="ftn.id529910" href="#id529910">13</a>] </sup>In LP64 data models</p></div><div class="footnote"><p><sup>[<a name="ftn.id529921" href="#id529921">14</a>] </sup>LP64 data model is used by gcc 64 bit compilers (long size is 8 bytes), MSVC uses a LLP64 model (long remains 4 bytes) but the LONG_PTR data type is platform dependent. More info at: <a href="http://en.wikipedia.org/wiki/64-bit#64-bit_data_models" target="_top">http://en.wikipedia.org/wiki/64-bit#64-bit_data_models</a> and <a href="http://www.amd.com/us-en/assets/content_type/DownloadableAssets/dwamd_AMD64_PortApp.pdf" target="_top">http://www.amd.com/us-en/assets/content_type/DownloadableAssets/dwamd_AMD64_PortApp.pdf</a> </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s10.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s12.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Direct memory manipulation </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Native Transactions</td></tr></table></div></body></html>
