<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Declaration and creation of native capable objects</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title=""><link rel="up" href="index.html" title=""><link rel="prev" href="ar01s04.html" title="Architecture"><link rel="next" href="ar01s06.html" title="Runtime Life Cycle"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Declaration and creation of native capable objects</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s04.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s06.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id519124"></a>Declaration and creation of native capable objects</h2></div></div></div><p>There are two types of native capable objects: predefined and user defined.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id519133"></a>Creation of predefined native capable objects</h3></div></div></div><p>The predefined native classes are hidden by the framework and cannot be created explicitly with new, related interfaces must be used against, and we need to specify what native interface is used to create a predefined native capable object. </p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id519142"></a>Creation with native types</h4></div></div></div><p>A native interface of a predefined native capable class is not ever a complete native type. An example is NativeString: a native string may be ANSI (char*) or UNICODE (wchar_t*), a native type may be necessary to create native capable objects of predefined classes.</p><p>To declare native types, the NativeTypeManager object is the direct way:</p><p>NativeTypeManager typeMgr = JNIEasy.get().getTypeManager();</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id519159"></a>Example: a native capable integer object.</h5></div></div></div><p>The NativeInteger is a final interface (native capable objects can be created) represents native integers (jint addressed values); a native object of this type is a jint in the native memory, and a Java reference can be seen as a jint* pointer. The TypeNativeObject.newValue() is used to create an object of the declared class.</p><p>TypeNativeObject typeInt = </p><p>(TypeNativeObject)typeMgr.dec(NativeInteger.class);</p><p>NativeInteger natInt = (NativeInteger)typeInt.newValue();</p><p>natInt.setIntValue(10);</p><p>When this native capable object is made native the 10 value is written on the related native memory (a jint). </p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id519191"></a>Example: a Unicode native capable string.</h5></div></div></div><p>TypeNativeString typeStr = typeMgr.decString(StringEncoding.UNICODE);</p><p>Now a native capable string object can be created using UNICODE encoding and wide character size, with the method TypeCanBeNativeCapable.wrapValue(Object) or the method TypeNativeString.newString(String):</p><p>NativeString natStr = (NativeString)typeStr.wrapValue("Hello");</p><p>Is equivalent to:</p><p>NativeString natStr2 = (NativeString)typeStr.newString("Hello");</p><p>Both native capable string objects contain the Java String "Hello". When any of them is made native, the "Hello" string using wchar_t characters and ended with '\0', will be written on the related native memory associated.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id519229"></a>Example: an array of Unicode string pointers.</h5></div></div></div><p>VarTypeNative varTypeStr = typeStr.decVarType();</p><p>TypeNativeArray typeStrArray = typeMgr.decArray(2,varTypeStr);</p><p>The returned type specifies string arrays with 2 elements. </p><p>NativeStringArray strArray = (NativeStringArray)typeStrArray.wrapValue(</p><p>new String[]{"hello","bye"});</p><p>When this object is made native, two new native strings are written to the native memory with the Unicode strings &#8220;hello&#8221; and &#8220;bye&#8221; and the two addresses are written on the new native array with two string pointers (wchar_t*).</p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id519269"></a>Creation with factories</h4></div></div></div><p>The interface factory, NativeCapableFactory , may be used as a shortcut to create objects of predefined native capable classes.</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id519279"></a>Example 1</h5></div></div></div><p>NativeCapableFactory objFact = JNIEasy.get().getNativeCapableFactory();</p><p>NativeString natStr = objFact.newString("Hello");</p><p>Creates a NativeString object with the default encoding (usually ANSI) </p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id519297"></a>Example 2</h5></div></div></div><p>NativeString natStr2 = (NativeString)objFact.wrapValue("Hello");</p><p>Is equivalent to the previous example, the method NativeCapableFactory.wrapValue(Object) expects a &#8220;can be native&#8221; object to be wrapped with the matching native capable object, the native type used is the default associated to the &#8220;can be native&#8221; object (an ANSI string).</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id519319"></a>Example 3</h5></div></div></div><p>NativeStringArray strArray = (NativeStringArray)objFact.wrapValue(</p><p>new String[]{"hello","bye"});</p><p>Creates a native capable string array holding the specified string array, the default string encoding will be used when made native.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id519338"></a>Example 4</h5></div></div></div><p>NativeInteger natInt = objFact.newNativeInteger(10);</p><p>Creates a NativeInteger object holding the value 10.</p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id519352"></a>Creation of proxies of DLL methods and fields</h4></div></div></div><p>The proxies of DLL methods (and fields seen as methods) are usually created using the DynamicLibrary instance of the DLL.</p><p>The following example maps and calls the C Win32 method: </p><p>HWND FindWindowA(LPCTSTR, LPCTSTR)</p><p>located in the Windows User32.dll, from Java:</p><p>DLLManager dllMgr = JNIEasy.get().getDLLManager();</p><p>DynamicLibrary dll = dllMgr.get("User32"); </p><p>CMethod method = dll.addCMethod("FindWindowA",int.class, </p><p>new Object[]{String.class,String.class},CallConv.STD_CALL);</p><p>int hwnd = method.callInt(new Object[]{null,"DDE Server Window"});</p><p>The returned CMethod object is already native and maps the specified C method, the callInt method execute a native call from Java. Note the .dll extension is removed in &#8220;User32&#8221; DLL name, the DLLManager.get(String) method can follows the System.loadLibrary(String) conventions: no extension and &#8220;lib&#8221; prefix (in Unixes) must be used, unless an absolute path is used.</p><p>JNIEasy uses java.library.path system property to specify where to look for dynamic libraries/shared objects (unless an absolute path is specified). This system property is usually set with the parameter &#8211;Djava.library.path on the command line.</p><p>Alternatively JNIEasy allows to specify java.library.path on runtime with the call:</p><p>JNIEasy.setFeature("java.library.path","pathList");</p><p>This call doesn&#8217;t change the real java.library.path system property (mandates JNIEasy to ignore the system property and use the specified path list).</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id519446"></a>Field-methods</h5></div></div></div>Field-methods<p>C global exported variables or C++ exported static fields can be accessed as native field-methods; there is no need to exist a &#8220;real&#8221; native field-method in the DLL.</p><p>The following example declares a global C variable exported in MyLibrary.dll/libMyLibrary.so/libMyLibrary.dylib:</p><p>// Any C or C++ .h file</p><p>extern "C" DLLEXPORT int aGlobalVar;</p><p>// Any C or C++ .c/.cpp file</p><p>int aGlobalVar;</p><p>Where DLLEXPORT macro is defined in JNIEasy.h as __declspec(dllexport) in Win32 compilers (VisualC++, MinGW, cygwin) and none in gcc Linux, Mac and Solaris (by default gcc on unixes exports all symbols<sup>[<a name="id519490" href="#ftn.id519490">2</a>]</sup>).</p><p>This variable is mapped from Java with a field-method native object.</p><p>The Java side:</p><p>DLLManager dllMgr = JNIEasy.get().getDLLManager();</p><p>DynamicLibrary dll = dllMgr.get("MyLibrary"); </p><p>CFieldMethod fieldMethod = </p><p>dll.addCFieldMethod("aGlobalVar",int.class,CallConv.STD_CALL); </p><p>int value = fieldMethod.callInt(NativeFieldMethod.GET,0); //or .getInt();</p><p>value += 10;</p><p>fieldMethod.callInt(NativeFieldMethod.SET,value) // or .setInt(value);</p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id519557"></a>Creation of proxies of native methods and fields if the address is known</h4></div></div></div><p>Another way to create a proxy of a native method is using NativeConstructor, NativeStaticMethod, NativeInstanceMethod, NativeStaticFieldMethod and NativeInstanceFieldMethod interfaces. Instances implementing these interfaces may be created using a native capable method signature. The native capable signature can be created with the NativeSignatureManager utility object, this object is obtained with the method JNIEasy.getSignatureManager().</p><p>In the following example the native method address is obtained with the method DynamicLibrary.getAddress(String), another scenarios are possible (including fields of structures declared as pointer to method)</p><p>DynamicLibrary dll = JNIEasy.get().getDLLManager().get("User32");</p><p>long methodAddress = dll.getAddress("FindWindowA");</p><p>NativeSignatureManager sigMgr = JNIEasy.get().getSignatureManager();</p><p>NativeStaticMethodSignature sig = sigMgr.decStaticMethod(int.class,</p><p>new Object[]{String.class,String.class},CallConv.STD_CALL); </p><p>NativeStaticMethod method = </p><p>(NativeStaticMethod)sig.attachBehavior(methodAddress);</p><p>int hwnd = method.callInt(new Object[]{null,"DDE Server Window"});</p><p>The returned NativeStaticMethod object is already native and maps the specified C method, the native call using the method callInt, invokes the native method in User32.dll from Java. </p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id519617"></a>Field-Methods</h5></div></div></div>Field-Methods<p>A special case is field-methods, the native address must be, really, the address of a native field-method. The following address:</p><p>long variableAddress = </p><p>dll.getAddress("aGlobalVariableOrStaticExportedFieldName");</p><p>is not a valid address to attach a NativeStaticFieldMethod, but the address of a CFieldMethod (obtained using NativeCapableUtil.getAddress(Object)) is a valid field-method address.</p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id519644"></a>Creation of direct and reflection callbacks</h4></div></div></div><p>A native capable object of these types may be created using a native method signature and a Java native capable method to call, this method (the method to be finally called) is represented by a reflection object (Method). A direct or reflection callback maps the Java method and can be passed to the native side (because they are native capable objects), the native side sees them as pointer-to-method, if this pointer-to-method is called the Java method is finally called, direct and reflection callbacks work as intermediaries in the calling process. A native object callback allocates native memory and has an address, this address is the native &#8220;pointer&#8221; of the Java method (of course is an illusion, it is the address of a native method created on the fly working as a bridge); this memory is freed when the object is garbage collected.</p><p>Example:</p><p>// Static method: java.lang.Math.max(int,int)</p><p>Method method = Math.class.getDeclaredMethod("max",</p><p>new Class[]{int.class,int.class});</p><p>NativeSignatureManager sigMgr = JNIEasy.get().getSignatureManager();</p><p>NativeMethodSignature sig = </p><p>sigMgr.decMethod(method,CallConv.STD_CALL); </p><p>Creation of a new reflection based callback and invoking it with a native call from Java: </p><p>NativeManager natMgr = JNIEasy.get().getNativeManager();</p><p>NativeStaticMethodReflection objReflect = </p><p>(NativeStaticMethodReflection)sig.newMethodReflection(method);</p><p>natMgr.makeNative(objReflect);</p><p>int max = objReflect.callInt(new Object[]{new Integer(5), new Integer(3)}); </p><p>System.out.println("Must be 5: " + max);</p><p>Creation of a new direct based callback and invoking it with a native call from Java:</p><p>NativeDirectStaticMethodCallback objDirectCb = </p><p>(NativeDirectStaticMethodCallback)sig.newDirectMethodCallback(method);</p><p>natMgr.makeNative(objReflect);</p><p>int max2 = objDirectCb.callInt(new Object[]{new Integer(5),new Integer(3)});</p><p>System.out.println("Must be 5: " + max2); </p><p>The objects, objReflect and objDirectCb, wrap the specified Java method (Math.max(int,int)) and make it visible from native. The reflection object (objReflect) uses reflection to call the method and the direct object (objDirectCb) uses a normal Java call (this object is an instance of a generated Java class &#8220;on the fly&#8221; if necessary). In this example the Java method can be called from native with a pointer with the signature: int (*)(int,int)</p><p>The method NativeManager.makeNative(Object) has been used the first time, this method converts a native capable object to a native object, after the call the Java object is associated to a chunk of native memory, in this case the cited native method created on the fly working as a bridge.</p><p>Following the example:</p><p>long address = NativeCapableUtil.getAddress(objReflect);</p><p>NativeStaticMethod proxy = </p><p>(NativeStaticMethod)sig.attachBehavior(address);</p><p>int max3 = proxy.callInt(new Object[]{new Integer(5),new Integer(3)}); </p><p>System.out.println("Must be 5: " + max3);</p><p>Using these techniques, native Java callbacks can be tested using Java only.</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id519833"></a>Field-methods</h5></div></div></div>Field-methods<p>Java native capable fields, static or instance, can be exported to the native world using direct and reflection native callbacks too. The fields do not need to be declared native, because reflection or direct access is used, in the case of instance fields, the container class must be native capable and a native instance must be used, but the field itself may be non-native (but the field type must be native enabled). </p><p>Example:</p><p>// Accessing the public final static field: java.lang.Math.PI</p><p>Field field = Math.class.getDeclaredField("PI");</p><p>NativeSignatureManager sigMgr = JNIEasy.get().getSignatureManager();</p><p>NativeFieldMethodSignature sig = </p><p>sigMgr.decFieldMethod(field,CallConv.STD_CALL); </p><p>NativeManager natMgr = JNIEasy.get().getNativeManager(); </p><p></p><p>// Using reflection</p><p></p><p>NativeStaticFieldMethodReflection objReflect = </p><p>(NativeStaticFieldMethodReflection)sig.newFieldMethodReflection(field);</p><p>natMgr.makeNative(objReflect);</p><p>double Pi1 = objReflect.getDouble(); </p><p>System.out.println("Must be true: " + (Pi1 == java.lang.Math.PI));</p><p></p><p>// Using a direct access </p><p></p><p>NativeDirectStaticFieldCallback objDirectCb = </p><p>(NativeDirectStaticFieldCallback)sig.newDirectFieldCallback(field);</p><p>natMgr.makeNative(objDirectCb);</p><p>double Pi2 = objDirectCb.getDouble();</p><p>System.out.println("Must be true: " + (Pi2 == java.lang.Math.PI));</p><p>Of course these native objects can be passed to the native side as pointer-to-methods following the field-method signature, the native side can access the Java fields calling these field-methods.</p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id519952"></a>Using Java reflection as proxy of native methods</h4></div></div></div><p>The NativeStaticMethodReflection interface is mainly used in Java callbacks invoked using reflection, the native instance holds a Method reference and this reflection object is used to call to the Java method. But there is an exception the native instance does not hold a Method reference, the internal reflection object is not defined, and we try to get something with a call to NativeStaticMethodReflection.getMethod()&#8230; in this case the framework is instructed to construct a new java.lang.reflect.Method object representing the native method with the address of the native instance, the native method can be called using this reflection object.</p><p>Example:</p><p>DynamicLibrary dll = JNIEasy.get().getDLLManager().get("User32");</p><p>long methodAddress = dll.getAddress("FindWindowA"); </p><p>NativeSignatureManager sigMgr = JNIEasy.get().getSignatureManager();</p><p>NativeStaticMethodSignature sig = sigMgr.decStaticMethod(int.class,</p><p>new Object[]{String.class,String.class},CallConv.STD_CALL); </p><p>TypeNativeStaticMethod type = </p><p>sig.decStaticMethod(NativeStaticMethodReflection.class);</p><p>NativeStaticMethodReflection obj = </p><p>(NativeStaticMethodReflection)type.newValue();</p><p>JNIEasy.get().getNativeManager().attach(obj,methodAddress);</p><p>Method method = obj.getMethod();</p><p>Integer hwnd = (Integer)method.invoke(null,</p><p>new Object[]{null,"DDE Server Window"});</p><p>System.out.println("Handle: " + hwnd.intValue());</p><p>This feature is transparent to the user reading a java.lang.reflect.Method field declared as a static method in a user defined Java class declared as a structure (C++ class or union), this field represents a &#8220;native pointer to method&#8221;, if this field was not set (from Java) before a first read, the Method object read represents the native method in the DLL.</p><p>If using the NativeInstanceMethodReflection interface in a similar scenario, the Method object returned with NativeInstanceMethodReflection.getMethod() is static, the C++ instance method can be called using as first parameter the native instance.</p><p>The NativeConstructorReflection interface works as expected; the java.lang.reflect.Constructor can be used to call the C method declared as constructor.</p><p>The interfaces NativeInstanceFieldMethodReflection and NativeStaticFieldMethodReflection do not work as proxy and an exception is thrown, the java.lang.reflect.Field can not be used as a proxy of a field-method.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id520085"></a>Creation of user defined JAVA native capable objects</h3></div></div></div>Creation of user defined JAVA native capable objects<p>An instance of a user defined Java native capable class (previously enhanced) works like an instance of the non-enhanced version, until the instance is made native. Instances can be created with the Java new sentence using the selected constructor by the user, this instance is not native (is a native capable object).</p><p>Example:</p><p>MyStructure struc = new MyStructure();</p><p>User defined Java classes will be explained later.</p><p></p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id519490" href="#id519490">2</a>] </sup>Inline methods (C and C++) and C static methods (using the static keyword) are not exported by default. A new visibility model have been introduced in gcc, more info: <a href="http://gcc.gnu.org/wiki/Visibility" target="_top">http://gcc.gnu.org/wiki/Visibility</a> and <a href="http://people.redhat.com/drepper/dsohowto.pdf" target="_top">http://people.redhat.com/drepper/dsohowto.pdf</a> </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s04.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s06.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Architecture </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Runtime Life Cycle</td></tr></table></div></body></html>
