<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Native Transactions</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title=""><link rel="up" href="index.html" title=""><link rel="prev" href="ar01s11.html" title="Cross-platform options"><link rel="next" href="ar01s13.html" title="Listeners"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Native Transactions</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s11.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s13.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id530775"></a>Native Transactions</h2></div></div></div><p>JNIEasy supports, optionally, transactional manipulations of native memory in a similar fashion as JDO or Hibernate. In native transactions the native memory must be seen as a data repository; during a native transaction the original state of the native memory is saved before any modification and is restored to the original values if the transaction is aborted (rollback).</p><p>A native transaction has boundaries (begin and end) and is thread isolated (transactions are not shared by threads). The thread isolation is the only one isolation offered by a native transaction, the same native memory fragment can be modified concurrently by two threads with one or two live transactions (JNIEasy avoids the concurrent modification but there is no thread lock between transactions); every transaction keeps track of the memory modifications performed by the associated thread only. If the user is going to modify the same native instance concurrently in a transactional environment is recommended to make a global lock during every transaction. </p><p>Native transactions only work keeping the state of fields from native capable classes; direct native memory manipulations with NativeBuffer and native modifications performed in the native side are not monitored and are not transactional.</p><p>Rollback behavior</p><div class="orderedlist"><ol type="1"><li><p>The native instance was made native inside the transaction: the allocated memory is freed.</p></li><li><p>The native instance was modified inside the transaction: the modified native memory is returned to the previous state to the modification.</p></li><li><p>The native instance was freed (non-native) inside the transaction: the instance is made native again and the values of the native memory are restored.</p></li></ol></div><p>The transaction object implementing the interface NativeTransaction, associated to the current (calling) thread can be obtained with the method:</p><p>NativeManager.currentTransaction()</p><p>A transaction begins with the method NativeTransaction.begin() and ends with the methods NativeTransaction.commit() and NativeTransaction.rollback().</p><p>Example:</p><p>NativeManager nativeMgr = JNIEasy.get().getNativeManager(); </p><p></p><p>MyStructure structUpdatedInside = new MyStructure();</p><p>structUpdatedInside.setIntArray4(new int[]{1,2});</p><p>nativeMgr.makeNative(structUpdatedInside);</p><p></p><p>MyStructure structNewInside = new MyStructure();</p><p>structNewInside.setIntArray4(new int[]{1,2});</p><p></p><p>MyStructure structFreedInside = new MyStructure();</p><p>nativeMgr.makeNative(structFreedInside);</p><p>structFreedInside.setIntArray4(new int[]{1,2});</p><p></p><p>NativeTransaction txn = nativeMgr.currentTransaction();</p><p></p><p>txn.begin();</p><p></p><p>nativeMgr.makeNative(structNewInside);</p><p>structNewInside.setIntArray4(new int[]{3,4});</p><p></p><p>nativeMgr.free(structFreedInside);</p><p>structFreedInside.setIntArray4(new int[]{3,4});</p><p></p><p>structUpdatedInside.setIntArray4(new int[]{3,4});</p><p></p><p>txn.rollback();</p><p></p><p>boolean res;</p><p>int[] array;</p><p></p><p>res = NativeCapableUtil.isNative(structNewInside);</p><p>System.out.println("Must be false: " + res); </p><p>array = structNewInside.getIntArray4();</p><p>System.out.println("Must be 1: " + array[0]); </p><p></p><p>res = NativeCapableUtil.isNative(structFreedInside);</p><p>System.out.println("Must be true: " + res);</p><p>array = structFreedInside.getIntArray4();</p><p>System.out.println("Must be 1: " + array[0]);</p><p></p><p>array = structUpdatedInside.getIntArray4(); </p><p>System.out.println("Must be 1: " + array[0]);</p><p></p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s11.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s13.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Cross-platform options </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Listeners</td></tr></table></div></body></html>
